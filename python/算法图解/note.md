##### 大O表示法

- 指出了算法的速度有多快, 能够比较操作数，它指出了算法运行时间的增速, 并非以秒为单位的速度
- 算法运行时间用大O表示法表示。大O表示法指出了最糟情况下的运行时间, 还应考虑平均情况的运行时间

```
O(1)	常量时间
O(n)	线性时间
```

##### 数组和链表

- 数组: 内存连续, 随机读取效率高, 添加和删除元素速度慢, 预留空间浪费空间
- 链表: 内存可以不连续, 跳跃查找效率低, 随机读取效率低
- 顺序访问: 从第一个元素开始逐个地读取元素. 链表只能顺序访问. 
- 随机访问: 可直接跳到某个元素. 

- 插入元素
  - 链表: 修改元素指向的地址
  - 数组: 将后面的元素向后移, 如果没有足够的空间将整个数组复制到其他地方

- 删除元素
  - 链表: 修改元素指向的地址
  - 数组: 元素向前移动

```
			数组			链表
读取		O(1)   	O(n)
写入		O(n)		O(1)
删除		O(n)		O(1)仅当删除访问的元素时才是1
```

##### 递归

- 递归只是让解决方案更清晰，并没有性能上的优势。实际上，在有些情况下，使用循环的性能更好
- 如果使用循环，程序的性能可能更高;如果使用递归，程序可能更容易理解。

##### 调用栈

- 用于存储多个函数的变量

- 函数压栈执行, 在栈顶添加了函数的内存块

- 调用另一个函数时，当前函数暂停 并处于未完成状态, 该函数的所有变量的值都还在内存中

- 当前函数执行完弹出, 返回上一个函数, 并从离开的地方开始接着往下执行
- 使用栈虽然很方便，但是也要付出代价:存储详尽的信息可能占用大量的内存。每个函数调 用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况 下，你有两种选择。
  - 重新编写代码，转而使用循环
  - 使用尾递归。这是一个高级递归主题，不在本书的讨论范围内。另外，并非所有的语言
    都支持尾递归

