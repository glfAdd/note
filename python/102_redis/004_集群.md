# x.04 集群

##### redis集群实现方式

- 主从复制

```
读写分离
假如 master宕机了, redis 没有实现自动进行主备切换



主从链
  - 从服务器也可以有从服务器
  - 从服务器对从服务器复制和从服务器对主服务器复制唯一区别在于, 如果从服务器X拥有从服务器Y, 那么当从服务器X在执行表步骤4时, 它将断开与从服务器Y的连接, 导致从服务器Y需要重新连接并重新同步
```

- Sentinel 哨兵机制

```
支持集群模式
着眼于高可用, 在 master 宕机时会自动将 slave 提升为master, 继续提供服务。
```

- cluster

```
负载均衡
解决单机redis容量有限的问题, 将数据按一定的规则分配到多台机器。

redis扩容方式
1. 垂直扩容表示通过加内存方式来增加整个缓存体系的容量比如将缓存大小由2G调整到4G,这种扩容不需要应用程序支持；
2. 水平扩容表示表示通过增加节点的方式来增加整个缓存体系的容量比如本来有1个节点变成2个节点, 这种扩容方式需要应用程序支持



分布式集群首要解决把整个数据集按照分区规则映射到多个节点的问题, 即把数据集划分到多个节点上, 每个节点负责整个数据的一个子集。redis Cluster采用哈希分区规则中的虚拟槽分区。
```

##### 复制

```
如果主从服务器之间的网络带宽不足, 或者主服务器没有足够的内存来创建子进程和创建记录写命令的缓冲区, 那么redis 处理命令请求的效率就会受到影响

最好还是让主服务器只使用50%~ 65%的内存, 留下30%~ 45%的内存用于执行BGSAVE命令和创建记录写命令的缓冲区。
从服务器在与主服务器进行初始连接时, 数据库中原有的所有数据都将丢失, 并被替换成主服务器发来的数据。
同时使用复制和AOF持久化将数据持久化到多台机器上面
```

| 步骤 | 主服务器操作                                                 | 从服务器操作                                                 |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | (等待命令进入)                                               | 连接主服务器, 发送SYNC命令                                   |
| 2    | 开始执行bgsave, 并使用缓冲区记录bgsave之后执行的所有命令     | 根据配置选项决定是否继续使用现有的数据处理客户端的命令请求, 还是想发送请求的客户端返回错误 |
| 3    | bgsave执行完毕向从服务器发送快照文件, 期间继续使用缓冲区记录被执行的写命令 | 丢弃所有旧数据, 载入主服务器发来的快照文件                   |
| 4    | 快照文件发送完毕, 开始向从服务器发送存储的缓冲区里的写命令                          完成快照文件解释操作, 并开始接收命令请求 | 完成快照文件解释操作, 并开始接收命令请求                     |
| 5    | 缓冲区存储的写命令发送完毕, 从现在开始每执行一个写命令就向从服务器发送相同的命令 | 执行主服务器发来的所有缓冲区里面的写命令. 从现在开始接收并执行主服务器传来的每个写命令 |

##### 短结构

```
短结构, 分片结构, 打包存储二进制和字节
```







# redis分布式锁

##### 分布式锁

- 正确做法

```
使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 (正确做法)
redis在 2.6.12 版本开始, 为 SET 命令增加一系列选项: 
SET key value[EX seconds][PX milliseconds][NX|XX]
    EX seconds: 设定过期时间, 单位为秒
    PX milliseconds: 设定过期时间, 单位为毫秒
    NX: 仅当key不存在时设置值(就等同于setnx命令)
    XX: 仅当key存在时设置值
    
    
# 当 test 不存在时, 创建并设置过期时间  
SET test 123 NX PX 10000
# 当 test 存在时, 创建并设置过期时间  
SET test 123 XX PX 10000
```

- 1. 使用redis setnx+expire命令 (错误的做法)

```
加锁命令: SETNX key value, 当键不存在时, 对键进行设置操作并返回成功, 否则返回失败。KEY 是锁的唯一标识, 一般按业务来决定命名。
解锁命令: DEL key, 通过删除键值对释放锁, 以便其他线程可以通过 SETNX 命令来获取锁。
锁超时: EXPIRE key timeout, 设置 key 的超时时间, 以保证即使锁没有被显式释放, 锁也可以在一定时间后自动释放, 避免资源被永远锁住。
SETNX 和 EXPIRE 非原子性
如果 SETNX 成功, 在设置锁超时时间后, 服务器挂掉、重启或网络问题等, 导致 EXPIRE 命令没有执行, 锁没有设置超时时间变成死锁。
```

- 2. 锁误解除

```
如果线程 A 成功获取到了锁, 并且设置了过期时间 30 秒, 但线程 A 执行时间超过了 30 秒, 锁过期自动释放, 此时线程 B 获取到了锁；随后 A 执行完成, 线程 A 使用 DEL 命令来释放锁, 但此时线程 B 加的锁还没有执行完成, 线程 A 实际释放的线程 B 加的锁。

通过在 value 中设置当前线程加锁的标识, 在删除之前验证 key 对应的 value 判断锁是否是当前线程持有。可生成一个 UUID 标识当前线程, 使用 lua 脚本做验证标识和解锁操作。
```

- 3. 超时解锁导致并发

```
如果线程 A 成功获取锁并设置过期时间 30 秒, 但线程 A 执行时间超过了 30 秒, 锁过期自动释放, 此时线程 B 获取到了锁, 线程 A 和线程 B 并发执行。

将过期时间设置足够长, 确保代码逻辑在锁释放之前能够执行完成。
为获取锁的线程增加守护线程, 为将要过期但未释放的锁增加有效时间。
```

- 4. 不可重入

```
当线程在持有锁的情况下再次请求加锁, 如果一个锁支持一个线程多次加锁, 那么这个锁就是可重入的。如果一个不可重入锁被再次加锁, 由于该锁已经被持有, 再次加锁会失败。redis 可通过对锁进行重入计数, 加锁时加 1, 解锁时减 1, 当计数归 0 时释放锁。

另一种方式是 redis Map 数据结构来实现分布式锁, 既存锁的标识也对重入次数进行计数
```

- 5. 无法等待锁释放

```

```



```
https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/







5. 无法等待锁释放
上述命令执行都是立即返回的, 如果客户端可以等待锁释放就无法使用。

可以通过客户端轮询的方式解决该问题, 当未获取到锁时, 等待一段时间重新获取锁, 直到成功获取锁或等待超时。这种方式比较消耗服务器资源, 当并发量比较大时, 会影响服务器的效率。
另一种方式是使用 redis 的发布订阅功能, 当获取锁失败时, 订阅锁释放消息, 获取锁成功后释放时, 发送锁释放消息。如下: 



集群
1. 主备切换
为了保证 redis 的可用性, 一般采用主从方式部署。主从数据同步有异步和同步两种方式, redis 将指令记录在本地内存 buffer 中, 然后异步将 buffer 中的指令同步到从节点, 从节点一边执行同步的指令流来达到和主节点一致的状态, 一边向主节点反馈同步情况。

在包含主从模式的集群部署方式中, 当主节点挂掉时, 从节点会取而代之, 但客户端无明显感知。当客户端 A 成功加锁, 指令还未同步, 此时主节点挂掉, 从节点提升为主节点, 新的主节点没有锁的数据, 当客户端 B 加锁时就会成功。


集群脑裂
集群脑裂指因为网络问题, 导致 redis master 节点跟 slave 节点和 sentinel 集群处于不同的网络分区, 因为 sentinel 集群无法感知到 master 的存在, 所以将 slave 节点提升为 master 节点, 此时存在两个不同的 master 节点。redis Cluster 集群部署方式同理。

当不同的客户端连接不同的 master 节点时, 两个客户端可以同时拥有同一把锁。



https://juejin.cn/post/6844903830442737671
```

# 消息队列

## list 队列

##### 1. LPUSH 和 RPOP

<img src=".\image\消息队列1.jpg" alt="消息队列1" style="zoom:100%;" />



```
1. 使用 LPUSH 和 RPOP, 时间复杂度都是 O(1)
2. 当队列中没有消息时, RPOP 返回 NULL, 得用循环的形式 RPOP 消息. 循环快了增加 redis 压力, 循环慢了导致消息不及时.
```

##### 2. BRPOP / BLPOP

<img src=".\image\消息队列2.jpg" alt="消息队列2" style="zoom:100%;" />

```
redis.brpop("queue", 0)

1. BRPOP 和 BLPOP 阻塞式读取命令, 客户端在没有读到队列数据时, 自动阻塞, 直到有新的数据写入队列, 再开始读取新数据.
2. 可以传入 '超时时间', 超时后返回 NULL. 0 表示不设置超时, 直到有新消息才返回

3. 如果超时太长, 这个连接太久没有活跃过, 可能会被 Redis Server 判定为无效连接, Redis Server 会强制断开这个客户端, 采用这种方案客户端要有重连机制
4. 不支持重复消费: 消费者拉取消息后, 这条消息就从 List 中删除了, 无法被其它消费者再次消费, 即不支持多个消费者消费同一批数据
5. 消息丢失: 消费者拉取到消息后, 如果发生异常宕机, 那这条消息就丢失了
```

## Pub/Sub (发布订阅模型)

##### 发布订阅流程

<img src=".\image\消息队列3.jpg" alt="消息队列3" style="zoom:100%;" />

<img src=".\image\消息队列4.jpg" alt="消息队列4" style="zoom:100%;" />

```
0. 可以有多个生产者和多个消费者
1. 发布订阅消息处理流程:
    a. 消费者订阅指定队列, Redis 会记录队列和消费者映射关系
    b. 生产者向这个队列发布消息, Redis 根据映射关系找出对应的消费者, 把消息转发给它
2. 消费者先订阅, 生产者再发消息, 否则丢消息
3. Pub/Sub 的实现没有基于任何数据类型, 整个过程中没有任何的数据存储, 都是实时转发, 只是单纯地为生产者和消费者建立「数据转发通道」, 把符合规则的数据, 从一端转发到另一端
4. 同一条数据可以被多个订阅者读取. 订阅支持表达式, 一个订阅者可以订阅多个队列
    > SUBSCRIBE queue123
    > PSUBSCRIBE queue*
5. 发布消息
	> PUBLISH queue123 msg1
```

##### 丢数据

```
1. 消费者下线: 如果一个消费者异常挂掉了, 下线期间生产者发布的消息被丢弃掉, 它再重新上线后, 只能接收新的消息
2. Redis 宕机: Pub/Sub 没有基于任何数据类型实现, 数据不会持久化, Pub/Sub 的操作不会写入到 RDB 和 AOF 中, 当 Redis 宕机重启, Pub/Sub 的数据也会全部丢失
```

##### 消息堆积

1. 消费者处理速度比生产者慢

2. list 作为列消息积压时, 消息积压时, 会导致这个链表很长, 内存会持续增长, 直到消费者把所有数据都从链表中取出

3. Pub/Sub 消息积压时会导致消费丢失. 每个消费者订阅一个队列时, Redis 会给这个消费者在分配一个缓冲区. 生产者发布消息时, Redis 先把消息写到对应消费者的缓冲区, 消费者从缓冲区读取消息. 从缓冲区取走数据之后, 数据就从 Redis 缓冲区删除. 缓冲区大小有限制, 如果消息积压 超过了缓冲区配置的上限, Redis 就会强制把这个消费者踢下线, 这时消费者就会消费失败, 也会丢失数据. 

4. 配置参数 client-output-buffer-limit pubsub 32mb 8mb 60

       client-output-buffer-limit pubsub 32mb 8mb 60
           32mb: 缓冲区一旦超过 32MB, Redis 直接强制把消费者踢下线
           8mb + 60: 缓冲区超过 8MB, 并且持续 60 秒, Redis 也会把消费者踢下线

## Stream 队列

##### 消息堆积

```
Redis 的据都存储在内存中, 消息积压会导致 Redis 内存增长, 如果超过机器内存上限, 就会面临被 OOM 的风险
Stream 可以指定队列最大长度, 当指定队列最大长度时, 队列长度超过上限后, 旧消息会被删除, 只保留固定长度的新消息

Kafka, RabbitMQ 专业的消息队列它们的数据都是存储在磁盘上, 当消息积压时, 无非就是多占用一些磁盘空间
因此, 把 Redis 当作队列来使用时, 会面临的 2 个问题：
Redis 本身可能会丢数据；
面对消息挤压, 内存资源会紧张；

所以, 能不能将 Redis 作为消息队列来使用, 关键看你的业务场景：
如果你的业务场景足够简单, 对于数据丢失不敏感, 而且消息积压概率比较小的情况下, 把 Redis 当作队列是完全可以的
如果你的业务有海量消息, 消息积压的概率比较大, 并且不能接受数据丢失, 那么还是用专业的消息队列中间件吧
```

##### 消息丢失

<img src=".\image\Stream消息队列.webp" alt="Stream消息队列" style="zoom:80%;" />

1. 生产者

   ```
   1. 发送消息时网络或其他问题导致发送失败, 需要重试
   2. 不确定是否发布成功, 网络问题导致发布超时, 可能数据已发送成功, 但读取响应结果超时了. 为了避免消息丢失, 只能继续重试, 直到发布成功为止, 消息可能重复. 生产者一般会设定一个最大重试次数, 超过上限依旧失败, 需要记录日志报警处理
   3. 消费者收到重复数据数据时, 要设计幂等逻辑, 保证业务的正确性
   ```

2. 消费者

   ```
   消费者处理完消息后, 需要执行 XACK 命令, Redis 把这条消息标记为 '处理完成'
   ```

3. redis 自身丢数据

   ```
   1. AOF 持久化配置为每秒写盘, 但这个写盘过程是异步的, Redis 宕机时会存在数据丢失的可能
   2. 主从复制也是异步的, 主从切换时, 也存在丢失数据的可能（从库还未同步完成主库发来的数据, 就被提成主库）
   ```

4. 消息堆积

   ```
   1. Redis 数据都存储在内存中, 旦发生消息积压, 则会导致 Redis 的内存持续增长, 如果超过机器内存上限, 就会面临被 OOM 的风险
   2. Stream 可以指定队列最大长度, 超过最大长度后丢弃旧的消息
   ```

##### 与专业消息队列对比

```
1. 如果业务场景足够简单, 对于数据丢失不敏感, 而且消息积压概率比较小的情况下, 把 Redis 当作队列是完全可以的. Redis 相比于 Kafka、RabbitMQ, 部署和运维也更加轻量. Kafka、RabbitMQ 数据都会存储在磁盘上, 磁盘的成本要比内存小得多, 当消息积压时, 无非就是多占用一些磁盘空间, 相比于内存, 在面对积压时也会更加「坦然」。
2. 如果业务场景对于数据丢失非常敏感, 而且写入量非常大, 消息积压时会占用很多的机器资源, 那么我建议你使用专业的消息队列中间件。Redis 在队列中间件环节无法保证消息不丢
```

# 应用问题

```
redis Sentinel 与 redis Cluster
https://blog.csdn.net/angjunqiang/article/details/81190562
```

##### redis的并发竞争问题如何解决?

```
redis为单进程单线程模式, 采用队列模式将并发访问变为串行访问。redis本身没有锁的概念, redis对于多个客户端连接并不存在竞争
```

##### 事务

```

```

##### redis 二级缓存

```

```

##### Redlock

```

```

##### pipline

```
pipeline就是用来将n次的网络时间优化为一次的网络时间, 耗时为1次网络时间 + n次命令时间


redis原生有类似 mget mset的批量操作命令, 这些命令都是原子的, 即会阻塞其他的命令, 知道命令完成返回。而pipeline的每一条命令是拆分过的（非原子）, 假设打包1000个命令的pipeline传到服务端, 则服务端会把pipeline的每个命令当成原子。但无论是pipeline还是M操作 返回的结果都是一样的。



pipeline与M操作都会将数据顺序的传送顺序地返回（redis 单线程）

1.每次pipeline携带数量不推荐过大, 否则会影响网络性能;
2.pipelinepipeline每次只能作用在一个redis节点上;
```

##### 原生M操作

```

```



##### 缓存数据库的双写一致性的问题

```
问题：一致性的问题是分布式系统中很常见的问题。一致性一般分为两种：强一致性和最终一致性, 当我们要满足强一致性的时候, Redis也无法做到完美无瑕, 因为数据库和缓存双写, 肯定会出现不一致的情况, Redis只能保证最终一致性。

解决：我们如何保证最终一致性呢？
    第一种方式是给缓存设置一定的过期时间, 在缓存过期之后会自动查询数据库, 保证数据库和缓存的一致性。如果不设置过期时间的话, 我们首先要选取正确的更新策略：先更新数据库再删除缓存。但我们删除缓存的时候也可能出现某些问题, 所以需要将要删除的缓存的key放到消息队列中去, 不断重试, 直到删除成功为止。
```

##### 缓存雪崩问题

```
问题： 我们应该都在电影里看到过雪崩, 开始很平静, 然后一瞬间就开始崩塌, 具有很强的毁灭性。这里也是一样的, 我们执行代码的时候将很多缓存的实效时间设定成一样, 接着这些缓存在同一时间都会实效, 然后都会重新访问数据库更新数据, 这样会导致数据库连接数过多、压力过大而崩溃。

解决：
    设置缓存过期时间的时候加一个随机值。设置双缓存, 缓存1设置缓存时间, 缓存2不设置, 1过期后直接返回缓存2, 并且启动一个进程去更新缓存1和2。
```

##### 缓存穿透问题

```
问题： 缓存穿透是指一些非正常用户(黑客)故意去请求缓存中不存在的数据, 导致所有的请求都集中到到数据库上, 从而导致数据库连接异常。

解决:

    利用互斥锁。缓存失效的时候, 不能直接访问数据库, 而是要先获取到锁, 才能去请求数据库。没得到锁, 则休眠一段时间后重试。采用异步更新策略。无论key是否取到值, 都直接返回。value值中维护一个缓存失效时间, 缓存如果过期, 异步起一个线程去读数据库, 更新缓存。需要做缓存预热(项目启动前, 先加载缓存)操作。提供一个能迅速判断请求是否有效的拦截机制。比如利用布隆过滤器, 内部维护一系列合法有效的key, 迅速判断出请求所携带的Key是否合法有效。如果不合法, 则直接返回。
```

##### 缓存的并发竞争问题

```
问题：

缓存并发竞争的问题, 主要发生在多线程对某个key进行set的时候, 这时会出现数据不一致的情况。

比如Redis中我们存着一个key为amount的值, 它的value是100, 两个线程同时都对value加100然后更新, 正确的结果应该是变为300。但是两个线程拿到这个值的时候都是100, 最后结果也就是200, 这就导致了缓存的并发竞争问题。

解决

    如果多线程操作没有顺序要求的话, 我们可以设置一个分布式锁, 然后多个线程去争夺锁, 谁先抢到锁谁就可以先执行。这个分布式锁可以用zookeeper或者Redis本身去实现。可以利用Redis的incr命令。当我们的多线程操作需要顺序的时候, 我们可以设置一个消息队列, 把需要的操作加到消息队列中去, 严格按照队列的先后执行命令。
```

##### redis 为什么高性能

```
影响 redis 性能的情况

4个方面: 网络, 磁盘, 内存, cpu


带宽: 读写, 同步数据都会受到影响
客户端连接数

内存: 
value 的大小
维护定时器
定时删除过期key: cup 资源紧张时删除 key 影响性能


磁盘性能: 如果缓冲区满了网磁盘持久化时, 如果磁盘写入速度不够快, 会阻塞写操作


bgrewriteaof: 重写 aof 文件时, 占用额外内存, 重写的文件过大导致操作系统挂起
```



# 参考

[官网文档](http://redis.cn/documentation.html)

##### 数据类型

- [x] https://blog.csdn.net/u012060033/article/details/129168155 全部数据类型
- [ ] https://www.cnblogs.com/kmcl1314/articles/15896129.html string
- [ ] https://zhuanlan.zhihu.com/p/364720565
- [ ] https://zhuanlan.zhihu.com/p/148562122
- [ ] https://zhuanlan.zhihu.com/p/593111008
- [x] https://zhuanlan.zhihu.com/p/64772193 1
- [ ] https://zhuanlan.zhihu.com/p/68667360 2
- [ ] https://juejin.cn/post/6844903951502934030
- [ ] https://cloud.tencent.com/developer/article/1667574
- [ ] https://cloud.tencent.com/developer/article/1442961?from=article.detail.1667574&areaSource=106000.12&traceId=DA3zaAlbl_6IooH3Cs-sm
- [ ] https://cloud.tencent.com/developer/article/1921542?from=article.detail.1442961&areaSource=106000.8&traceId=iaayeX_P3We0kPNxU543b
- [ ] https://zhuanlan.zhihu.com/p/528146852 详细
- [ ] https://zhuanlan.zhihu.com/p/345618221
- [ ] https://www.cnblogs.com/hunternet/p/12742390.html
- [ ] https://www.cnblogs.com/qdhxhz/p/15669348.html
- [ ] https://www.cnblogs.com/bbgs-xc/p/14376109.html
- [ ] http://kaito-kidd.com/2021/04/19/can-redis-be-used-as-a-queue/
- [ ] https://zhuanlan.zhihu.com/p/358366217 rehash (有问题)
- [ ] https://juejin.cn/post/7027757834943234085 rehash

##### 基本原理

- [ ] https://zhuanlan.zhihu.com/p/364494952
- [ ] https://xiaolincoding.com/redis/cluster/master_slave_replication.html#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%8C%E6%AD%A5 看看

##### 消息队列

- [ ] https://jingzh.blog.csdn.net/article/details/116257400 
- [ ] https://mp.weixin.qq.com/s/uhMrqR__6qgpl7vrE_otTQ

##### 内存管理

- [ ] https://juejin.cn/post/6844903982628864007
- [ ] https://mp.weixin.qq.com/s/SrQIGL_X8wC1eFsGu8gBXg
- [ ] 

- **[Redis 数据类型和应用场景](https://link.zhihu.com/?target=https%3A//xiaolincoding.com/redis/data_struct/command.html)**
  - **[图解 Redis 数据结构](https://link.zhihu.com/?target=https%3A//xiaolincoding.com/redis/data_struct/data_struct.html)**
- 持久化篇 
- - **[AOF 持久化是怎么实现的？](https://link.zhihu.com/?target=https%3A//xiaolincoding.com/redis/storage/aof.html)**
  - **[RDB 快照是怎么实现的？](https://link.zhihu.com/?target=https%3A//xiaolincoding.com/redis/storage/rdb.html)** 
- 集群篇 
- - **[什么是缓存雪崩、击穿、穿透？](https://link.zhihu.com/?target=https%3A//xiaolincoding.com/redis/cluster/cache_problem.html)**
  - **[主从复制是怎么实现的？](https://link.zhihu.com/?target=https%3A//xiaolincoding.com/redis/cluster/master_slave_replication.html)**
  - **[为什么要有哨兵？](https://link.zhihu.com/?target=https%3A//xiaolincoding.com/redis/cluster/sentinel.html)**
- 架构篇 
- - **[数据库和缓存如何保证一致性？](https://link.zhihu.com/?target=https%3A//xiaolincoding.com/redis/architecture/mysql_redis_consistency.html)**



