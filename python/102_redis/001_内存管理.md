# 文档

[官网文档](http://redis.cn/documentation.html)





# 数据类型

##### 内部编码

<img src=".\image\数据结构2.webp" alt="数据结构2" style="zoom:80%;" />

<img src=".\image\数据结构.png" alt="数据结构" style="zoom:30%;" />

```
redis 的 key 限制为 512MB

redis 是以 key - value 存储的数据结构服务器, 所有的 key 是字符串, 而 value 可以包含:
    字符串类型（string）: 最基本的数据类型, 二进制安全的字符串, 最大512M
    列表类型（list）: 按照添加顺序保持顺序的字符串列表
    集合类型（set）: 无序的字符串集合, 不存在重复的元素
    有序集合类型（sorted set或Zset）: 已排序的字符串集合
    散列类型（hash）: key-value对的一种集合
    位操作（bitmap）: 更细化的一种操作, 以bit为单位。
    基数统计（hyperloglog）: 基于概率的数据结构, 2.8.9新增
    地理位置（Geo）: 地理位置信息储存起来,  并对这些信息进行操作 3.2新增
    流（Stream） 5.0新增
```

```
redis 的 key 和 string 类型 value 限制均为 512MB
key 太大影响检索性能
```

## string

### int

### embstr

### raw

```
string 是二进制安全, 可以包含任何数 (数字, 字符串, 图片等)
最大 512MB

```

##### 内部编码

> SDS (Simple Dynamic String): 简单动态字符串

```
int: 8个字节的长整型 (long, 2^63-1)
embstr: 小于等于 44 个字节的字符串, embstr 格式的 SDS
raw: SDS 大于 44 个字节的字符串

Redis 为什么要自己写一个 SDS 的数据类型, 主要是为了解决C语言 char[] 的四个问题: 
    字符数组必须先给目标变量分配足够的空间, 否则可能会溢出
    查询字符数组长度, 时间复杂度O(n)
    长度变化, 需要重新分配内存
    通过从字符串开始到结尾碰到的第一个\0来标记字符串的结束, 因此不能保存图片、音频、视频、压缩文件等二进制(bytes)保存的内容, 二进制不安全

Redis SDS的优势: 
    不用担心内存溢出问题, 如果需要会对 SDS 进行扩容
    因为定义了 len 属性, 查询数组长度时间复杂度O(1) 固定长度
    空间预分配, 惰性空间释放
    根据长度 len来判断是否结束, 而不是 \0

为什么要有embstr编码呢？比raw的优势在哪里？
    embstr 编码将创建字符串对象所需的空间分配的次数从raw编码的两次降低为一次。
    因为emstr编码字符串的素有对象保持在一块连续的内存里面, 所以那个编码的字符串对象比起raw编码的字符串对象能更好的利用缓存。并且释放embstr编码的字符串对象只需要调用一次内存释放函数, 而释放raw编码对象的字符串对象需要调用两次内存释放函数
```

##### 命令

```
set k v
get k
del k

incr k                  值自增1
decr k                  值自减1
incrby k n              值加n
decrbu k n              值减n
incrbyfloat k n         值加浮点n

append k v              值末尾追加字符串
getrange k start end    获取start和end之间字符
setrange k start v      从start开始替换为v
getbit
setbit
bitcount
bitop

* 对不存在的值进行自增/自减, 会将这个值当0处理
* 对无法解释为整数/浮点的字符串自增/自减返回错误
```

## list

```
字符串列表
```

```
lpush k v1 v2           左边添加多个元素
rpush k v1 v2           右边添加多个元素
lpop k
rpop k
lindex k v              获取指定位置上一个元素
lrange k start end      获取指定范围所有元素
ltrim k start end       只保留start和end及之间的元素  

blpop k timeout         从第一个非空列表中弹出最左边元素, 或timeout内等待可弹出的元素出现                   
brpop                                        右
rpoplpush k1 k2         弹出k1最右边, 推入k2最左, 并获取这个元素
brpoplpush k1 k2 timeout弹出k1最右边, 推入k2最左, 并获取这个元素, 如果k1位空则阻塞timeout直到元素出现
```

## set

```
string类型的无序集合, 集合是通过哈希表实现的, 所以添加, 删除, 查找的复杂度都是O(1)
且不允许重复的成员
```



```
sadd k v1 v2            添加1个/多个元素, 获取不存在新增加的个数        
srem k v1 v2            删除1个/多个元素, 获取删除的个数
scard k                 获取元素个数
smembers k              获取所有元素
sismember k v           是否包含元素v
srandmember k count     随机获取count个元素, 当count为正数时元素不重复, 负数时可以重复
spop k                  随机移除一个元素并获取元素
smove k1 k2 v           如果k1有元素v则移动到k2则
```

## zset

```
zset(有序集合)
string类型元素的集合, 且不允许重复的成员。
格式: zadd  name score value
不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
zset的成员是唯一的,但分数(score)却可以重复。
```



```
zadd k s1 v1 s2 v2      将分数s1 s2和元素添加到集合
zrem k v1 v2            移除元素, 并获取成功的数量            
zcard k                 获取元素数量
zincrby k count v       v的分数增加count
zcount k s1 s2          获取分数s1和s2之间元素数量
zrank k v               获取元素的排名
zscore k v              获取元素的分值
zrange k start stop [withscores]    返回排名start和stop之间的成员, 如果有withscores则一起返回分数
```

## hash

```
hset k1 k2 v
hget k1 k2
hdel k1 k2
hgetall k1              获取所有键值对
hmget K k1 k2           获取1个/多个键的值
hmset K k1 v1 k2 v2     添加1个/多个值
hdel K k1 k2            获取成功删除的数量
hlen K                  获取键值对的数量
hexists K k             查看k是否存在
hkeys K k               删除
hvals K                 获取所有值
hgetall K               获取所有键值对
hincrby K k count       值加上count
hincrbyfloat K k count  值加上count 浮zrange点
```

## HyperLogLogs 基数统计

## Geospatial 地理位置

## BitMaps 位图



```
expire
persist
```

<img src=".\image\redis过期时间.png" alt="redis过期时间" style="zoom:80%;" />

# 内存管理

```
设置最大内存, 避免Redis内存使用过多对其他程序造成影响

redis.conf 文件, redis.conf 文件默认的最大内存 maxmemory=0 表示不限制Redis内存的使用
```

### 删除策略

> 只能删除过期数据
>
> redis 同时使用了惰性删除与定期删除

##### 1. 定时删除

- 含义: 在设置 key 的过期时间的同时, 为该key创建一个定时器, 让定时器在 key 的过期时间来临时对 key 进行删除

- 优点: 保证内存被尽快释放

- 缺点:

  - 若过期 key很多, 删除这些key会占用很多的CPU时间, 在CPU时间紧张的情况下, CPU不能把所有的时间用来做要紧的事儿, 还需要去花时间删除这些key
  - 定时器的创建耗时,若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生）, 性能影响严重


##### 2. 惰性删除

- 含义: key 过期的时候不删除, 每次通过key获取值的时候去检查是否过期, 若过期则删除并返回不存在
- 优点: 节约CPU性能, 发现不得不删除的时候才删除
- 缺点: 内存空间压力大

##### 3. 定期删除

- 每隔一段时间, 我们就对一些key进行检查, 删除里面过期的key。
- 优点
  - 可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响, 解决"定时删除"对 cpu 影响的问题
  - 释放过期键占用的内存, 解决"惰性删除"对内存占用的问题.
- 缺点
  - 难以确定删除操作执行的时长（每次删除执行多长时间）和频率（每隔多长时间做一次删除)。如果执行的太频繁, 定期删除策略变得和定时删除策略一样, 对CPU不友好。如果执行的太少, 那又和惰性删除一样了, 过期键占用的内存不会及时得到释放。
  - 在获取某个键时, 如果某个键的过期时间已经到了, 但是还没执行定期删除, 那么就会返回这个键的值

### 淘汰策略

> 新数据写入时, redis 使用的内存达到上限时
>
> 设置 redis 使用内存的上限

> https://blog.csdn.net/qq_37325859/article/details/125331084

- 每次存储数据前调用 freeMemoryIfNeeded() 检测内存是否充足。如果内存不满足新加入数据的最低存储要求, redis要临时删除一些数据为当前指令清理存储空间. 有时需要反复执行才能才是释放足够的空间. 当对所有数据尝试完毕后, 如果不能达到内存清理的要求, 将出现错误 "OOM command not allowed when used memory>'maxmemory'"

##### 参数

```
maxmemory: redis可使用内存占物理内存的最大比例, 默认为0, 表示不限制redis使用内存。生产环境中根据需求设定, 通常设置在50%以上
maxmemory-samples: 每次选取待删除数据的个数, 选取数据时并不会全库扫描, 导致严重的性能消耗, 降低读写性能。因此采用随机获取数据的方式作为待检测删除数据
maxmemory-policy: 达到最大内存后的, 对被挑选出来的数据进行删除的算法
```

##### 淘汰算法

```
volatile-lru, 针对设置了过期时间的key, 使用lru算法进行淘汰
volatile-lfu, 针对设置了过期时间的key, 使用lfu算法进行淘汰。
volatile-random, 从所有设置了过期时间的key中使用随机淘汰的方式进行淘汰。
volatile-ttl, 针对设置了过期时间的key, 越早过期的越先被淘汰。
allkeys-lru, 针对所有key使用lru算法进行淘汰。
allkeys-lfu, 针对所有key使用lfu算法进行淘汰。
allkeys-random, 针对所有的key使用随机淘汰机制进行淘汰。
noeviction, 不会淘汰任何数据, 当使用的内存空间超过 maxmemory 值时, 再有写请求来时会引发错误OOM（Out Of Memory）
```

##### LRU

```
Least Recently Used 最近很少使用




问题:
一个很久没有被访问的key, 偶尔被访问一次, 导致被误认为是热点数据的问题
```

##### redis LRU

- 3.0 版本以前

  ```
  随机采集淘汰的key, 每次随机选出5个key, 然后淘汰这5个key中最少使用的key
  数量可设置, 值越大越准确, 道消耗资源增加
  ```

- 3.0 版本以后

- > 空闲时长: 多久没有用了. 优先淘汰空闲时长大的

  ```
  1. 维护一个池子存放随机选取的 key, 并根据空闲时长排序
  2. 大于池内最小空闲时长的才能追加入池子
  3. 池子满了以后, 将空闲时长最长的移出池子并淘汰.
  ```

##### LFU

> 4.0 版本加入

```
根据key最近被访问的频率进行淘汰, 比较少访问的key优先淘汰, 反之则保留。
LFU的原理是使用计数器来对key进行排序, 每次key被访问时, 计数器会增大, 当计数器越大, 意味着当前key的访问越频繁, 也就是意味着它是热点数据
```

##### 最大限制

```
string 最大 512M

List、Set、Sorted Set 可以放 2 的 32 次方个元素(受内存影响)
```



# 持久化



> 持久化: 把内存的数据写入磁盘, 防止服务宕机内存数据丢失. 持久化所得的文件最好备份到不同的服务器

### rdb 快照

##### 快照频率

```
save N M
	在 N 秒内至少 M 个改动才触发一次 rdb
	
save 200 20
	200 秒内至少 20 个改动
```

##### 手动执行快照

```
save
或
gbsave
```



```
redis 默认使用快照方式, 默认文件名 dump.rdb 的二进制文件, 每次执行覆盖之前的内容.


创建子进程进行快照
系统发生崩溃丢失快照后更改的所有数据. 适用于丢失一部份数据也不会造成问题的应用程序

例子
  - 如果内存有10GB数据, 上一个快照2:31开始创建并成功, 3:12开始创建快照, 创建之前有51个键进行更新
  - 如果创建成功之前系统崩溃, 则丢失2:31之后的所有数据
  - 如果创建成功以后系统崩溃, 则丢失51的更新

配置文件
save 60 1000
stop-writes-on-bgsave-error no
rdbcompression yes
dbfilename dump.rdb
```

### AOF

- 将被执行的写命令写到AOF文件末尾, 以此来记录发生的变化. 

- 缺陷
  - Redis不断运行, AOF文件不断增长, 在极端情况下, 体积不断增大的AOF文件甚至可能会用完硬盘的所有可用空间
  - 重新执行AOF文件记录的所有写命令来还原数据集, 如果AOF文件的体积非常大, 还原操作执行的时间就可能会非常长

##### 同步频率 appendfsync

- always: 每个写命令都同步写入硬盘, 严重降低 redis 速度, 用户几乎可以不损失任何数据每次只写入一条命令, 其他选项一次写入多条命令这种同步频率下, 机械硬盘每秒大约处理200个命令, 固态硬盘几万个命令
- everysec: 每秒执行一次同步. 兼顾数据安全和写入性能, 每秒同步一次AOF文件时的性能和不使用任何持久化特性时的性能相差无几
  系统崩溃用户也最多只会丢失一秒之内产生的数据。当硬盘忙于执行写人操作的时候, Redis还会优雅地放慢自己的速度以便适应硬盘的最大写人速度。
- no: 由操作系统来决定应该在何时对AOF文件进行同步.  一般情况下不会对Redis的性能带来影响, 但系统崩溃将导致使用这种选项的Redis服务器丢失不定数量的数据. 如果用户的硬盘处理写入操作的速度不够快的话,那么当缓冲区被等待写入硬盘的数据填满时, Redis 的写操作将被阻塞, 并导致Redis处理命令请求的速度变慢

##### bgrewriteaof

```
为了解决AOF文件体积不断增大的问题, 用户可以向Redis发送BGREWRITEAOF命令, 这个命令会通过移除AOF文件中的冗余命令来重写AOF文件, 使AOF文件的体积变得尽可能地小。


1. Redis创建一个子进程重写AOF文件, 会导致的性能问题和内存占用问题
2. AOF文件的体积可能会比快照文件的体积大好几倍, 在进行AOF重写并删除旧AOF文件的时候, 删除一个体积达到数十GB大的旧AOF文件可能会导致操作系统挂起数秒
```

##### 配置文件

```
appendonly no
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb  
# 当AOF文件体积大于64MB, 且AOF文件的体积比上一次重写之后的体积大了至少100%时候, Redis将执行BGREWRITEAOF命令
```

# 集群

##### redis集群实现方式

- 主从复制

```
读写分离
假如 master宕机了, Redis 没有实现自动进行主备切换



主从链
  - 从服务器也可以有从服务器
  - 从服务器对从服务器复制和从服务器对主服务器复制唯一区别在于, 如果从服务器X拥有从服务器Y, 那么当从服务器X在执行表步骤4时, 它将断开与从服务器Y的连接, 导致从服务器Y需要重新连接并重新同步
```

- Sentinel 哨兵机制

```
支持集群模式
着眼于高可用, 在 master 宕机时会自动将 slave 提升为master, 继续提供服务。
```

- cluster

```
负载均衡
解决单机Redis容量有限的问题, 将数据按一定的规则分配到多台机器。

redis扩容方式
1. 垂直扩容表示通过加内存方式来增加整个缓存体系的容量比如将缓存大小由2G调整到4G,这种扩容不需要应用程序支持；
2. 水平扩容表示表示通过增加节点的方式来增加整个缓存体系的容量比如本来有1个节点变成2个节点, 这种扩容方式需要应用程序支持



分布式集群首要解决把整个数据集按照分区规则映射到多个节点的问题, 即把数据集划分到多个节点上, 每个节点负责整个数据的一个子集。Redis Cluster采用哈希分区规则中的虚拟槽分区。
```

##### 复制

```
如果主从服务器之间的网络带宽不足, 或者主服务器没有足够的内存来创建子进程和创建记录写命令的缓冲区, 那么Redis 处理命令请求的效率就会受到影响

最好还是让主服务器只使用50%~ 65%的内存, 留下30%~ 45%的内存用于执行BGSAVE命令和创建记录写命令的缓冲区。
从服务器在与主服务器进行初始连接时, 数据库中原有的所有数据都将丢失, 并被替换成主服务器发来的数据。
同时使用复制和AOF持久化将数据持久化到多台机器上面
```

| 步骤 | 主服务器操作                                                 | 从服务器操作                                                 |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | (等待命令进入)                                               | 连接主服务器, 发送SYNC命令                                   |
| 2    | 开始执行bgsave, 并使用缓冲区记录bgsave之后执行的所有命令     | 根据配置选项决定是否继续使用现有的数据处理客户端的命令请求, 还是想发送请求的客户端返回错误 |
| 3    | bgsave执行完毕向从服务器发送快照文件, 期间继续使用缓冲区记录被执行的写命令 | 丢弃所有旧数据, 载入主服务器发来的快照文件                   |
| 4    | 快照文件发送完毕, 开始向从服务器发送存储的缓冲区里的写命令                          完成快照文件解释操作, 并开始接收命令请求 | 完成快照文件解释操作, 并开始接收命令请求                     |
| 5    | 缓冲区存储的写命令发送完毕, 从现在开始每执行一个写命令就向从服务器发送相同的命令 | 执行主服务器发来的所有缓冲区里面的写命令. 从现在开始接收并执行主服务器传来的每个写命令 |

##### 短结构

```
短结构, 分片结构, 打包存储二进制和字节
```



# 连接池

```
通过预先创建多个连接, 当进行redis操作时, 直接获取已经创建的连接进行操作, 而且操作完成后, 不会释放, 用于后续的其他redis操作, 这样就达到了避免频繁的redis连接创建和释放的目的, 从而提高性能。
redis模块采用ConnectionPool来管理对redis server的所有连接


```



# 性能问题

影响 redis 性能的情况

4个方面: 网络, 磁盘, 内存, cpu

```
带宽: 读写, 同步数据都会受到影响
客户端连接数

内存: 
value 的大小
维护定时器
定时删除过期key: cup 资源紧张时删除 key 影响性能


磁盘性能: 如果缓冲区满了网磁盘持久化时, 如果磁盘写入速度不够快, 会阻塞写操作


bgrewriteaof: 重写 aof 文件时, 占用额外内存, 重写的文件过大导致操作系统挂起


```



# redis分布式锁

- 正确做法

```
使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 (正确做法)
Redis在 2.6.12 版本开始, 为 SET 命令增加一系列选项: 
SET key value[EX seconds][PX milliseconds][NX|XX]
    EX seconds: 设定过期时间, 单位为秒
    PX milliseconds: 设定过期时间, 单位为毫秒
    NX: 仅当key不存在时设置值(就等同于setnx命令)
    XX: 仅当key存在时设置值
```

- 1. 使用redis setnx+expire命令 (错误的做法)

```
加锁命令: SETNX key value, 当键不存在时, 对键进行设置操作并返回成功, 否则返回失败。KEY 是锁的唯一标识, 一般按业务来决定命名。
解锁命令: DEL key, 通过删除键值对释放锁, 以便其他线程可以通过 SETNX 命令来获取锁。
锁超时: EXPIRE key timeout, 设置 key 的超时时间, 以保证即使锁没有被显式释放, 锁也可以在一定时间后自动释放, 避免资源被永远锁住。
SETNX 和 EXPIRE 非原子性
如果 SETNX 成功, 在设置锁超时时间后, 服务器挂掉、重启或网络问题等, 导致 EXPIRE 命令没有执行, 锁没有设置超时时间变成死锁。
```

- 2. 锁误解除

```
如果线程 A 成功获取到了锁, 并且设置了过期时间 30 秒, 但线程 A 执行时间超过了 30 秒, 锁过期自动释放, 此时线程 B 获取到了锁；随后 A 执行完成, 线程 A 使用 DEL 命令来释放锁, 但此时线程 B 加的锁还没有执行完成, 线程 A 实际释放的线程 B 加的锁。

通过在 value 中设置当前线程加锁的标识, 在删除之前验证 key 对应的 value 判断锁是否是当前线程持有。可生成一个 UUID 标识当前线程, 使用 lua 脚本做验证标识和解锁操作。
```

- 3. 超时解锁导致并发

```
如果线程 A 成功获取锁并设置过期时间 30 秒, 但线程 A 执行时间超过了 30 秒, 锁过期自动释放, 此时线程 B 获取到了锁, 线程 A 和线程 B 并发执行。

将过期时间设置足够长, 确保代码逻辑在锁释放之前能够执行完成。
为获取锁的线程增加守护线程, 为将要过期但未释放的锁增加有效时间。
```

- 4. 不可重入

```
当线程在持有锁的情况下再次请求加锁, 如果一个锁支持一个线程多次加锁, 那么这个锁就是可重入的。如果一个不可重入锁被再次加锁, 由于该锁已经被持有, 再次加锁会失败。Redis 可通过对锁进行重入计数, 加锁时加 1, 解锁时减 1, 当计数归 0 时释放锁。

另一种方式是 Redis Map 数据结构来实现分布式锁, 既存锁的标识也对重入次数进行计数
```

- 5. 无法等待锁释放

```

```



```
https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/







5. 无法等待锁释放
上述命令执行都是立即返回的, 如果客户端可以等待锁释放就无法使用。

可以通过客户端轮询的方式解决该问题, 当未获取到锁时, 等待一段时间重新获取锁, 直到成功获取锁或等待超时。这种方式比较消耗服务器资源, 当并发量比较大时, 会影响服务器的效率。
另一种方式是使用 Redis 的发布订阅功能, 当获取锁失败时, 订阅锁释放消息, 获取锁成功后释放时, 发送锁释放消息。如下: 



集群
1. 主备切换
为了保证 Redis 的可用性, 一般采用主从方式部署。主从数据同步有异步和同步两种方式, Redis 将指令记录在本地内存 buffer 中, 然后异步将 buffer 中的指令同步到从节点, 从节点一边执行同步的指令流来达到和主节点一致的状态, 一边向主节点反馈同步情况。

在包含主从模式的集群部署方式中, 当主节点挂掉时, 从节点会取而代之, 但客户端无明显感知。当客户端 A 成功加锁, 指令还未同步, 此时主节点挂掉, 从节点提升为主节点, 新的主节点没有锁的数据, 当客户端 B 加锁时就会成功。


集群脑裂
集群脑裂指因为网络问题, 导致 Redis master 节点跟 slave 节点和 sentinel 集群处于不同的网络分区, 因为 sentinel 集群无法感知到 master 的存在, 所以将 slave 节点提升为 master 节点, 此时存在两个不同的 master 节点。Redis Cluster 集群部署方式同理。

当不同的客户端连接不同的 master 节点时, 两个客户端可以同时拥有同一把锁。



https://juejin.cn/post/6844903830442737671
```

# 旧

```
Redis Sentinel 与 Redis Cluster
https://blog.csdn.net/angjunqiang/article/details/81190562
```

##### redis的并发竞争问题如何解决?

```
Redis为单进程单线程模式, 采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念, Redis对于多个客户端连接并不存在竞争
```

##### 事务

```

```

##### redis 二级缓存

```

```

##### Redlock

```

```

##### pipline

```
pipeline就是用来将n次的网络时间优化为一次的网络时间, 耗时为1次网络时间 + n次命令时间


redis原生有类似 mget mset的批量操作命令, 这些命令都是原子的, 即会阻塞其他的命令, 知道命令完成返回。而pipeline的每一条命令是拆分过的（非原子）, 假设打包1000个命令的pipeline传到服务端, 则服务端会把pipeline的每个命令当成原子。但无论是pipeline还是M操作 返回的结果都是一样的。



pipeline与M操作都会将数据顺序的传送顺序地返回（redis 单线程）

1.每次pipeline携带数量不推荐过大, 否则会影响网络性能;
2.pipelinepipeline每次只能作用在一个Redis节点上;
```

##### 原生M操作

```

```

# 参考

##### 数据类型

- [ ] https://blog.csdn.net/u012060033/article/details/129168155
- [ ] https://zhuanlan.zhihu.com/p/364720565
- [ ] https://zhuanlan.zhihu.com/p/148562122
- [ ] https://blog.csdn.net/qq_31960623/article/details/117911710
- [ ] https://zhuanlan.zhihu.com/p/593111008
- [ ] https://zhuanlan.zhihu.com/p/64772193
- [ ] https://zhuanlan.zhihu.com/p/68667360
- [ ] https://zhuanlan.zhihu.com/p/371375530
- [ ] https://juejin.cn/post/6844903951502934030
- [ ] https://cloud.tencent.com/developer/article/1667574
- [ ] https://cloud.tencent.com/developer/article/1442961?from=article.detail.1667574&areaSource=106000.12&traceId=DA3zaAlbl_6IooH3Cs-sm
- [ ] https://cloud.tencent.com/developer/article/1921542?from=article.detail.1442961&areaSource=106000.8&traceId=iaayeX_P3We0kPNxU543b

##### 基本原理

- [ ] https://zhuanlan.zhihu.com/p/364494952
- [ ] https://cloud.tencent.com/developer/article/1158989?from=article.detail.1442961&areaSource=106000.9&traceId=iaayeX_P3We0kPNxU543b



