##### redis 内存组成

<img src=".\image\内存管理1.png" alt="内存管理1" style="zoom:80%;" />

- used_memory_rss：Redis 主进程的内存（单位是 KB）
  - 内存碎片：如果对数据的更改频繁，可能导致 redis 释放的空间在物理内存中并没有释放，但 redis 又无法有效利用，这就形成了内存碎片。
  - 运行内存：运行时消耗的内存，一般占用内存较低，在 10M 内。
  - used_memory: Redis 内存占用中最主要的部分（单位是KB）
    - 自身内存：自身维护的一些数据字典及元数据，一般占用内存很低。
    - 对象内存：所有对象都是 Key-Value 型，Key 对象都是字符串，Value 对象则包括 5 种类（String，List，Hash，Set，Zset）
    - 缓存：客户端缓冲区（普通 + 主从复制 + pubsub）以及 aof 缓冲区。
    -  Lua 内存：主要是存储加载的 Lua 脚本，内存使用量和加载的 Lua 脚本数量有关。
- 子进程内存：在持久化的时候，aof rewrite 或者 rdb 产生的子进程消耗的内存，一般也是比较小。

##### 内存使用优化策略

```
1. 在完整描述业务情况下，key 越短越好
2. value 中去掉不必要的属性, 减少 value 的长度
```



```
共享对象池

对象共享池指Redis内部维护[0-9999]的整数对象池。
创建大量的整数类型 redisObject 存在内存开销，每个 redisObject 内部结构至少占16字节，甚至超过了整数自身空间消耗。
所以 Redis 内存维护一个[0-9999]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。
可以通过object refcount 命令查看对象引用数验证是否启用整数对象池技术。

```





```
设置最大内存, 避免redis内存使用过多对其他程序造成影响

redis.conf 文件, redis.conf 文件默认的最大内存 maxmemory=0 表示不限制redis内存的使用
```

### 删除策略

> 只能删除过期数据
>
> redis 同时使用了惰性删除与定期删除

##### 1. 定时删除

- 含义: 在设置 key 的过期时间的同时, 为该key创建一个定时器, 让定时器在 key 的过期时间来临时对 key 进行删除

- 优点: 保证内存被尽快释放

- 缺点:

  - 若过期 key很多, 删除这些key会占用很多的CPU时间, 在CPU时间紧张的情况下, CPU不能把所有的时间用来做要紧的事儿, 还需要去花时间删除这些key
  - 定时器的创建耗时,若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生）, 性能影响严重


##### 2. 惰性删除

- 含义: key 过期的时候不删除, 每次通过key获取值的时候去检查是否过期, 若过期则删除并返回不存在
- 优点: 节约CPU性能, 发现不得不删除的时候才删除
- 缺点: 内存空间压力大

##### 3. 定期删除

- 每隔一段时间, 我们就对一些key进行检查, 删除里面过期的key。
- 优点
  - 可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响, 解决"定时删除"对 cpu 影响的问题
  - 释放过期键占用的内存, 解决"惰性删除"对内存占用的问题.
- 缺点
  - 难以确定删除操作执行的时长（每次删除执行多长时间）和频率（每隔多长时间做一次删除)。如果执行的太频繁, 定期删除策略变得和定时删除策略一样, 对CPU不友好。如果执行的太少, 那又和惰性删除一样了, 过期键占用的内存不会及时得到释放。
  - 在获取某个键时, 如果某个键的过期时间已经到了, 但是还没执行定期删除, 那么就会返回这个键的值

### 淘汰策略

> 新数据写入时, redis 使用的内存达到上限时
>
> 设置 redis 使用内存的上限

> https://blog.csdn.net/qq_37325859/article/details/125331084

- 每次存储数据前调用 freeMemoryIfNeeded() 检测内存是否充足。如果内存不满足新加入数据的最低存储要求, redis要临时删除一些数据为当前指令清理存储空间. 有时需要反复执行才能才是释放足够的空间. 当对所有数据尝试完毕后, 如果不能达到内存清理的要求, 将出现错误 "OOM command not allowed when used memory>'maxmemory'"

##### 参数

```
maxmemory: redis可使用内存占物理内存的最大比例, 默认为0, 表示不限制redis使用内存。生产环境中根据需求设定, 通常设置在50%以上
maxmemory-samples: 每次选取待删除数据的个数, 选取数据时并不会全库扫描, 导致严重的性能消耗, 降低读写性能。因此采用随机获取数据的方式作为待检测删除数据
maxmemory-policy: 达到最大内存后的, 对被挑选出来的数据进行删除的算法
```

##### 淘汰算法

```
volatile-lru, 针对设置了过期时间的key, 使用lru算法进行淘汰
volatile-lfu, 针对设置了过期时间的key, 使用lfu算法进行淘汰。
volatile-random, 从所有设置了过期时间的key中使用随机淘汰的方式进行淘汰。
volatile-ttl, 针对设置了过期时间的key, 越早过期的越先被淘汰。
allkeys-lru, 针对所有key使用lru算法进行淘汰。
allkeys-lfu, 针对所有key使用lfu算法进行淘汰。
allkeys-random, 针对所有的key使用随机淘汰机制进行淘汰。
noeviction, 不会淘汰任何数据, 当使用的内存空间超过 maxmemory 值时, 再有写请求来时会引发错误OOM（Out Of Memory）
```

##### LRU

```
Least Recently Used 最近很少使用




问题:
一个很久没有被访问的key, 偶尔被访问一次, 导致被误认为是热点数据的问题
```

##### redis LRU

- 3.0 版本以前

  ```
  随机采集淘汰的key, 每次随机选出5个key, 然后淘汰这5个key中最少使用的key
  数量可设置, 值越大越准确, 道消耗资源增加
  ```

- 3.0 版本以后

- > 空闲时长: 多久没有用了. 优先淘汰空闲时长大的

  ```
  1. 维护一个池子存放随机选取的 key, 并根据空闲时长排序
  2. 大于池内最小空闲时长的才能追加入池子
  3. 池子满了以后, 将空闲时长最长的移出池子并淘汰.
  ```

##### LFU

> 4.0 版本加入

```
根据key最近被访问的频率进行淘汰, 比较少访问的key优先淘汰, 反之则保留。
LFU的原理是使用计数器来对key进行排序, 每次key被访问时, 计数器会增大, 当计数器越大, 意味着当前key的访问越频繁, 也就是意味着它是热点数据
```

##### 最大限制

```
string 最大 512M

List、Set、Sorted Set 可以放 2 的 32 次方个元素(受内存影响)
```


