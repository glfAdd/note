```
expire
persist
```

<img src=".\image\redis过期时间.png" alt="redis过期时间" style="zoom:80%;" />

#### redis 服务内存设置

```
设置最大内存, 避免Redis内存使用过多对其他程序造成影响

redis.conf 文件, redis.conf 文件默认的最大内存 maxmemory=0 表示不限制Redis内存的使用
```

#### 删除策略

> 只能删除过期数据
>
> redis 同时使用了惰性删除与定期删除

##### 1. 定时删除

- 含义: 在设置 key 的过期时间的同时, 为该key创建一个定时器, 让定时器在 key 的过期时间来临时对 key 进行删除

- 优点: 保证内存被尽快释放

- 缺点:

  - 若过期 key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key
  - 定时器的创建耗时,若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重


##### 2. 惰性删除

- 含义: key 过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期则删除并返回不存在
- 优点: 节约CPU性能，发现不得不删除的时候才删除
- 缺点: 内存空间压力大

##### 3. 定期删除

- 每隔一段时间，我们就对一些key进行检查，删除里面过期的key。
- 优点
  - 可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响, 解决"定时删除"对 cpu 影响的问题
  - 释放过期键占用的内存, 解决"惰性删除"对内存占用的问题.
- 缺点
  - 难以确定删除操作执行的时长（每次删除执行多长时间）和频率（每隔多长时间做一次删除)。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。
  - 在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值

#### 淘汰策略

> 新数据写入时, redis 使用的内存达到上限时
>
> 设置 redis 使用内存的上限

> https://blog.csdn.net/qq_37325859/article/details/125331084

- 每次存储数据前调用 freeMemoryIfNeeded() 检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间. 有时需要反复执行才能才是释放足够的空间. 当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误 "OOM command not allowed when used memory>'maxmemory'"
- 

##### 参数

```
maxmemory: redis可使用内存占物理内存的最大比例，默认为0，表示不限制redis使用内存。生产环境中根据需求设定，通常设置在50%以上
maxmemory-samples：每次选取待删除数据的个数，选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据
maxmemory-policy：达到最大内存后的，对被挑选出来的数据进行删除的算法
```

##### 淘汰算法

```
volatile-lru，针对设置了过期时间的key，使用lru算法进行淘汰
volatile-lfu，针对设置了过期时间的key，使用lfu算法进行淘汰。
volatile-random，从所有设置了过期时间的key中使用随机淘汰的方式进行淘汰。
volatile-ttl，针对设置了过期时间的key，越早过期的越先被淘汰。
allkeys-lru，针对所有key使用lru算法进行淘汰。
allkeys-lfu，针对所有key使用lfu算法进行淘汰。
allkeys-random，针对所有的key使用随机淘汰机制进行淘汰。
noeviction，不会淘汰任何数据，当使用的内存空间超过 maxmemory 值时，再有写请求来时会引发错误OOM（Out Of Memory）
```

##### LRU

```
Least Recently Used 最近很少使用




问题:
一个很久没有被访问的key，偶尔被访问一次，导致被误认为是热点数据的问题
```

##### redis LRU

- 3.0 版本以前

  ```
  随机采集淘汰的key，每次随机选出5个key, 然后淘汰这5个key中最少使用的key
  数量可设置, 值越大越准确, 道消耗资源增加
  ```

- 3.0 版本以后

- > 空闲时长: 多久没有用了. 优先淘汰空闲时长大的

  ```
  1. 维护一个池子存放随机选取的 key, 并根据空闲时长排序
  2. 大于池内最小空闲时长的才能追加入池子
  3. 池子满了以后, 将空闲时长最长的移出池子并淘汰.
  ```

##### LFU

> 4.0 版本加入

```
根据key最近被访问的频率进行淘汰，比较少访问的key优先淘汰，反之则保留。
LFU的原理是使用计数器来对key进行排序，每次key被访问时，计数器会增大，当计数器越大，意味着当前key的访问越频繁，也就是意味着它是热点数据
```



