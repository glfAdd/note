```
上下文: 在多线程和多进程中记录了某个线程执行的状态，包括线程里用到的各个变量，线程的调用栈等
```

```
1. 异步函数就是携程 coroutine
2. 函数前面加上 async 就是异步函数, 函数里面可以使用 await
3. await 后面必须跟一个 awaitable 类型或者具有 __await__ 属性的对象.
4. sleep() 不是 awaitable, 会导致线程阻塞的 "真性睡眠"
5. 使用asyncio 库的 sleep()
    await asyncio.sleep(3)
6. 异步函数不能直接执行, 需要使用事件循环
    创建一个事件循环
    将异步函数加入事件队列
    执行事件队列, 直到最晚的一个事件被处理完毕后结束
    最后建议用 close() 方法关闭事件循环, 以彻底清理 loop 对象防止误用
```

##### asyncio 控制事件循环

```python
# 得到当前上下文的事件循环
loop = asyncio.get_event_loop()
# 延后 time_delay 秒再执行 callback 方法
loop.call_later(time_delay, callback, argument)
# 尽可能快调用 callback, call_soon() 函数结束主线程回到事件循环之后就会马上调用 callback
loop.call_soon(callback, argument)
# 以float类型返回当前时间循环的内部时间
loop.time()
# 为当前上下文设置事件循环
asyncio.set_event_loop()
# 根据此策略创建一个新的事件循环并返回
asyncio.new_event_loop()
# 在调用 stop() 之前将一直运行
loop.run_forever()
```

##### 异步生成器

```python

```

### 异步编程

```
与多线程和多进程编程模型相比，异步编程只是在同一个线程之内的的任务调度，无法充分利用多核CPU的优势，所以特别适合IO阻塞性任务；
```

##### 执行过程

```
event loops: 跟踪和调度所有异步任务
coroutines: 对具体执行任务的封装
futures: coroutines的执行结果

1. 首先事件循环启动之后，会从任务队列获取第一个要执行的coroutine，并随之创建对应task和future
2. 然后随着task的执行，当遇到coroutine内部需要切换任务的地方，task的执行就会暂停并释放执行线程给event loop，event loop接着会获取下一个待执行的coroutine，并进行相关的初始化之后，执行这个task;

3. 随着event loop执行完队列中的最后一个coroutine才会切换到第一个coroutine;
4. 随着task的执行结束，event loops会将task清除出队列，对应的执行结果会同步到future中，这个过程会持续到所有的task执行结束;
```

##### 实现异步编程的方式

```
https://www.jianshu.com/p/beb147e27041
gevent
yield (弃用)
asyncio.coroutine (弃用)
async, await (3.7 之后这是原生方式, 推荐用这个)
```

##### 进程 线程 携程

```
进程

不共享任何状态
调度由操作系统完成
有独立的内存空间
通讯主要通过信号传递的方式来实现（实现方式有多种，信号量、管道、事件等，通讯都需要过内核，效率低）

线程
共享变量（解决了通讯麻烦的问题，但是对于变量的访问需要加锁）
调度由操作系统完成（由于共享内存，上下文切换变得高效）
一个进程可以有多个线程，每个线程会共享父进程的资源（创建线程开销占用比进程小很多，可创建的数量也会很多）
通讯除了可使用进程间通讯的方式，还可以通过共享内存的方式进行通信（通过共享内存通信比通过内核要快很多）

协程
调度完全由用户控制
一个线程（进程）可以有多个协程
每个线程（进程）循环按照指定的任务清单顺序完成不同的任务（当任务被堵塞时，执行下一个任务；当恢复时，再回来执行这个任务；任务间切换只需要保存任务的上下文，没有内核的开销，可以不加锁的访问全局变量）
协程需要保证是非堵塞的且没有相互依赖
协程基本上不能同步通讯，多采用异步的消息通讯，效率比较高

总结
进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度
线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)
协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度
```

##### linux IO多路复用

```
select、poll、epoll
```

#### even loop 事件循环

```
1、事件循环是在线程中执行
2、从队列中取得任务
3、每个任务在协程中执行下一步动作
4、如果在一个协程中调用另一个协程（await ），会触发上下文切换，挂起当前协程，并保存现场环境（变量，状态），然后载入被调用协程
5、如果协程的执行到阻塞部分（阻塞I/O，Sleep），当前协程会挂起，并将控制权返回到线程的消息循环中，然后消息循环继续从队列中执行下一个任务．．．以此类推
6、队列中的所有任务执行完毕后，消息循环返回第一个任务
```

#### Coroutine (协程对象)

```
1. 协程对象: 通过调用协程函数返回的对象
2. 协程对象本质上是一个函数, 指一个使用 async 关键字定义的函数, 它的调用不会立即执行函数, 而是会返回一个协程对象。协程对象由事件循环调用.
3. await 只能用在协程对象里, 用于中断当前协程的执行, event loop 会执行其他携程
4. await 后边的表达式需要返回 waitable 的对象
```

##### Awaitables

```
Awaitables 可等待对象. 主要有三种类型 :coroutine, Task, Future
实现 __await__() 的对象
```

##### Futures

```
它和task上没有本质的区别

1. 代表携程任务执行的结果, 可能还没开始执行, 异步操作结束后会赋值给这个 Future 对象上
2. Future对象有一个result属性，用于存放未来的执行结果。
3. 还有个set_result()方法，是用于设置result的，并且会在给result绑定值以后运行事先给Future对象添加的回调
4. 回调是通过Future对象的add_done_callback()方法添加的。
5. Future 是协程的封装
```

##### Future 状态

```
Future对象有几个状态：
    Pending：就绪
    Running：运行
    Done：完成
    Cancelled：取消
```

##### Task

```
1. Task 是 Future 的子类, 提供了回调/取消的方法
2. 一个事件循环每次运行一个Task对象当一个Task对象等待一个Future对象完成时，该事件循环会运行其他Task、回调或执行IO操作

创建 task 方法 (Python 3.7 中被加入)
future1= asyncio.create_task(my_coroutine)
```

