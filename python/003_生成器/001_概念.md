

<img src=".\image\关系.png" alt="关系" style="zoom:50%;" />

```
container: 容器
iterable: 可迭代对象
iterator: 迭代器
generator: 生成器
```

##### iter

```

```

##### for 循环原理

<img src=".\image\for循环原理.png" alt="for循环原理" style="zoom:45%;" />

```python
x = [1, 2, 3]
for i in x:
    print(i)
```



```
>>> x = [1, 2, 3]
>>> a = iter(x)
>>> b = iter(x)
>>> next(a)
1
>>> next(a)
2
>>> next(b)
1
>>> type(x)
<class 'list'>
>>> type(a)
<class 'list_iterator'>
>>> type(b)
<class 'list_iterator'>
```

```
这里的 x 是一个可迭代对象, 可迭代对象和容器一样是一种通俗的叫法, 并不是指某种具体的数据类型, 
list 是可迭代对象, 
dict 也是可迭代对象。
a 和 b 是两个独立的迭代器, 迭代器内部有一个状态, 该状态用于记录当前迭代所在的位置, 以方便下次迭代时获取正确的元素。
迭代器有一种具体的迭代器类型, 比如 list_iterator, set_iterator。可迭代对象实现了 __iter__() 方法, 该方法返回一个迭代器对象。








```





# iterable (可迭代对象)

```
实现了 __iter__ 方法的对象就是可迭代对象
调用iter()方法返回 iterator
```



# Iterator (迭代器)

```
实现了 __iter__ 和 __next__ 方法的对象就是迭代器, 迭代器有状态, 调用 next() 方法时返回下一个值
__iter__ 返回迭代器自身
__next__ 返回容器中的下一个值, 如果没有元素了, 则抛出 StopIteration 异常

迭代器与列表的区别在于, 构建迭代器的时候, 不像列表把所有元素一次性加载到内存, 而是以一种延迟计算（lazy evaluation）方式返回元素, 这正是它的优点。
比如列表中含有一千万个整数, 需要占超过100M的内存, 而迭代器只需要几十个字节的空间。因为它并没有把所有元素装载到内存中, 而是等到调用next()方法的时候才返回该元素（按需调用 call by need 的方式, 

itertools 模块里的函数返回的都是迭代器对象

序列都可以迭代
实现 __iter__ 或 __getitem__ 方法的对象
```

##### 自定义迭代器

```python
class Test:
    def __iter__(self):
        self.a = 1
        return self

    def __next__(self):
        x = self.a
        self.a += 1
        return x


a = Test()
b = iter(a)
print(next(b))
print(next(b))
print(next(b))
```

```python
class Test:
    def __init__(self) -> None:
        self.age = []

    def __getitem__(self, i):
        return self.age[i]


a = Test()
a.age = ["apple", "banana"]
for i in a:
    print(i)
```

# generator (生成器)

```
1. 包含 yield 的函数, 执行后返回生成器
2. 执行 __next__ 方法才会执行函数体, 并且获得返回值, 
遇到 yield 函数会暂停并保存当前所有的运行信息, 返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行
可以对 yield 表达式进行赋值, 也可以将 yield 表达式的值返回

3. __next__ 相当于 next(), 超出范围报错 StopIteration
3. 生成器包括两种: 生成器函数和生成器表达式
2. next() 内置方法, 内部调用生成器函数的 __next__() 方法



# yield 相当于 return, 下一次循环从 yield 的下一行开始

迭代: 扫描内存放不下数据时, 惰性获取数据方式, 一次获取一个数据


包含关键字 yield 的函数, 不会执行任何函数代码, 直到对调用next() 或 send(None)
第一次调用时必须先next() 或 send(None) 否则会报错
```

##### 自定义生成器

##### send

```python
def test(x):
    print("第一次进入")
    for i in range(x):
        one = yield i
        print("one --- %s" % one)
        two = yield i
        print("two --- %s" % two)


# 返回一个生成器, 函数不会执行
t = test(10)
# 进入函数执行代码, 遇到yield函数返回
a = t.send(None)
# 再次进入函数体, 把 100 传给变量 one, 遇到 yield 函数返回
b = t.send(100)
c = next(t)
d = next(t)
e = t.__next__()
f = t.__next__()
print("-----------")
```

##### for 循环

```
本质上 for 循环就是不断地调用迭代器的 next() 方法


for 循环原理:
1. for 调用 __iter__() 方法, 返回迭代器
2. for 调用 next() 方法, next 调用迭代器的 __next__(), 每次返回迭代器的下一个值,
3. 迭代器没有值抛出 StopIteration, for 循环退出
```

# yield

```
__iter__
  - 返回当前对象的迭代器实例
  - 直观理解就是能用for循环进行迭代的对象就是可迭代对象. 比如：字符串, 列表, 元祖, 字典, 集合

__next__
  - 就是从上一个终止点开始，到下一个yield结束，返回值就是yield表达式的值
  - 返回容器中的下一个值, 直到抛出StopIteration异常

sent()
  - 可以传递参数给yield表达式
  - 生成器第一次使用必须是 None

next()
  - 内置函数 next() 通过迭代器调用 __next__ 方法返回下一项
  - 返回容器中的下一个值, 直到抛出StopIteration异常

iter()
  - 内置函数. 如果对象实现了__iter__方法可获取迭代器对象

yield
  - 类似 return
  - 迭代一次遇到yield时就返回yield后面的值
  - 下一次迭代时，从上一次迭代遇到的yield后面的代码开始执行

for ... in
  - 1. 调用可迭代对象的__inter__方法返回一个迭代器对象（iterator）
  - 2. 不断调用迭代器的__next__方法返回元素
  - 3. 迭代完成后, 处理StopIteration异常
```

##### iter

```python

```

##### itertools

```

```

##### 推导式

```python
# 这个是生成器推导式
a = (x for x in range(5))
# 不是
b = [x for x in range(5)]
# 不是
c = {x: x for x in range(5)}
```

