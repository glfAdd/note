> 参考: https://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html

```
证书: 公钥+申请者信息 + 颁发者信息+签名
CA (Certificate Authority): 证书授权中心, 是负责管理和签发证书的第三方机构
CA证书: ca 颁发的证书
```

## 概念

##### 对称加密 

```
使用同一
个秘钥来加密和解密, 使用相同的加密算法. 速度比非对称加密快. 常用加密算法 DES、IDEA、RC2、RC4、SKIPJACK、RC5、AES 等
```

##### 非对称加密

```
公钥 (publickey) 和私钥 (privatekey), 他们是一对. 加密和解密用的是不同的密钥, 公钥加密的数据只能用对应的私钥解密, 私钥加密的数据只能用对应的公钥解密. 私钥永远只能服务器掌握. 常用算法 RSA(使用最多)、Elgamal、背包算法、Rabin、D-H、ECC
从私钥可推导出公钥, 但从公钥不能推导出私钥
```

##### 对称加密和非对称加密算法比较

> https://blog.csdn.net/wgw335363240/article/details/8878584

```
对称加密(AES):
    AES加密的时间与被加密文件的大小正线性增长，加密1G的文件大概需要4分多钟，加密速度较快。
    加密后的文件大小是原始文件大小的两倍。
    解密文件所需时间是加密时间的两倍（这个应该是加密文件是原始文件大小两倍造成的）。

非对称加密(RSA):
    RSA加密算法加密时间很短，基本可以忽略不计。但是，在解密时，RSA显的比较慢，解密时间与解密文件 的大小呈现线性增长趋势。加密1M的文件大概需要5秒，但是解密却需要4分钟。
    加密后的文件与原始文件的大小基本相同。
    解密的效率远低于加密效率，按照这个时间去计算，加密1G的文件需要1分钟，但是解密却需要65小时。
```

##### 签名

```
在信息的后面再加上一段内容, 可以证明信息没有被修改过. 一般是计算信息 hash 值, 发送信息时把 hash 值加密后做为一个签名和信息一起发出去. 接收方也计算信息的 hash 值, 与解密收到的 hash 值比较两者是否一致. 消息和 hash 值可能同时被修改, 所以 hash 值是加密后再和消息一起发送. 

hash: 计算是不可逆的, 无法通过 hash 值得出原来的信息内容
```

##### 数字签名

- 作用
  - 用私钥签名的明文, 只有对应的公钥才能解密
  - 完整性没有被篡改
  - 源认证，由谁发出
  - 不可否认性，使用谁的公钥解密，说明是谁发出的

- 过程
  - A 用 Hash 把明文生成数字摘要
  - A 用自己的私钥加密数字摘要, 形成数字签名
  - A 把原始明文和数字签名一起发给 B, B 用 A 的公钥对数字签名解密, 得到数字摘要同时对明文使用相同 Hash 产生数字摘要, 将两个数字摘要进行对比, 两者一致则说明信息没有被破坏
- 存在的问题: 接收方存储的发送方的公钥伪造问题
- 解决办法: CA 通过自己的私钥对发送方的公钥进行加密发送给接收方，这样就可以保证发送方的公钥的正确性，最简单的数字证书，就是使用CA的私钥对需要验证的用户的公钥和信息的加密

##### 数字信封

- 被公钥加密后的对称密码被称为数字信封
- 作用: 用于对称密钥的交换

- 过程
  - 发送方发送消息时, 先生成**对称密钥** (用于加密要发送的明文)
  - 发送方用接收方的公钥加密对称密钥, 形成密钥密文
  - 发送方将1和2的结果结合在一起，形成数字信封，一并传给接收方，接收方接收到密文后，使用自己的私钥解密密钥密文，得到对称密钥，在使用对称密钥解密DES密文，得到真正的原始明文

##### 数字证书

- 由证书颁发机构签发的电子数据, 公钥与唯一实体绑定
- 作用: 验证发送方身份

## 加密通信过程

> C 客户端
>
> S 服务端

##### 明文直接发送

- 过程

  ```
  C -> S ：你好
  S -> C ：你好, 我是服务器
  ```

- 问题

  ```
  黑客在 C 和 S 之间的某个路由器上截获 C 发给服务器的信息, 然后自己冒充 S
  C 在接到消息后, 并不能肯定这个消息就是由 S 发出的
  
  
  C ->“黑客”：你好
  “黑客”-> C ：你好, 我是服务器
  ```

#####  公钥和私钥

- 过程

  ```markdown
  C -> S ：你好
  S -> C ：你好, 我是服务器
  C -> S ：向我证明你就是服务器
  # S 把一个字符串用自己的私钥加密, 把明文和加密后的密文一起发给 C 
  # C 收到信息后用自己持有的公钥解密, 和明文对比是否一致. 一致表示消息发送方有对应的私钥, 对方是服务器
  S -> C ：你好, 我是服务器 {你好, 我是服务器}[私钥|RSA]
  ```

- 问题

  ```
  公钥是发布出来的, 其他人也可以用相同的公钥解密 C 和 S 之间的信息
  ```

##### 对称加密

- 过程

  ```markdown
  C -> S ：你好
  S -> C ：你好, 我是服务器
  C -> S ：向我证明你就是服务器
  S -> C ：你好, 我是服务器 {你好, 我是服务器}[私钥|RSA]
  # C 确认 S 的身份后,  C 自己选择一个对称加密算法和一个密钥, 把这个对称加密算法和密钥一起用公钥加密后发送给 S
  # 就算这个加密后的内容被“黑客”截获了, 由于没有私钥, “黑客”也无从知道对称加密算法和密钥的内容。
  # 之后 S 和 C 就可以用对称加密算法和密钥来加密通信的内容
  C -> S ：{我们后面的通信过程, 用对称加密来进行, 这里是对称加密算法和密钥}[公钥|RSA]
  S -> C ：{OK, 收到！}[密钥|对称加密算法]
  C -> S ：{我的帐号是aaa, 密码是123, 把我的余额的信息发给我看看}[密钥|对称加密算法]
  S -> C ：{你的余额是100元}[密钥|对称加密算法]
  ```

- 问题

  ```
  这里问题的根源就在于, 大家都可以生成公钥、私钥对, 无法确认公钥对到底是谁的
  ```

##### 证书

- 过程

  ```markdown
  数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的, 或者证书可以用来确认对方的身份
  
  
  # C 向服务端发送一个通信请求
  C -> S ：你好
  #  S 向客户发送自己的数字证书。证书中有一个公钥用来加密信息, 私钥由 S 持有
  S -> C ：你好, 我是服务器, 这里是我的数字证书
  # C 收到 S 的证书后, 它会去验证这个数字证书到底是不是 S 的, 如果是服务器的, 就说明里面的公钥也是服务器的
  # C 会发送一个随机的字符串给 S 用私钥去加密
  C -> S ：....... (随机字符串)
  # 服务器用私钥加密随机字符串, 并返回给 C 
  # C 用公钥解密这个返回结果, 如果解密结果与之前生成的随机字符串一致, 那说明对方确实是私钥的持有者, 或者说对方确实是 S 。
  S -> C ：...... (服务器私钥加密后的随机字符串)
  # 验证 S 的身份后,  C 生成一个对称加密算法和密钥, 用于后面的通信的加密和解密。这个对称加密算法和密钥,  C 会用公钥加密后发送给 S , 别人截获了也没用, 因为只有 S 手中有可以解密的私钥。这样, 后面 S 和 C 就都可以用对称加密算法来加密和解密通信内容了。
  C -> S ：{我们后面的通信过程, 用对称加密来进行, 这里是对称加密算法和密钥}[公钥|RSA]  
  S -> C ：{OK, 收到！}[密钥|对称加密算法]
  C -> S ：{我的帐号是aaa, 密码是123, 把我的余额的信息发给我看看}[密钥|对称加密算法]
  S -> C ：{你的余额是100元}[密钥|对称加密算法]
  ```

##### 其他问题

- 问题1:

  ```
  检查完证书后, “客户”发送一个随机的字符串给“服务器”去用私钥加密, 以便判断对方是否真的持有私钥。
  黑客可以发送一些简单的有规律的字符串给“服务器”加密, 从而寻找加密的规律, 
  “服务器”随随便便用私钥去加密一个来路不明的字符串并把结果发送给对方是不安全的
  
  
  收到“客户”发来的要加密的的字符串时, “服务器”并不是真正的加密这个字符串本身, 而是把这个字符串进行一个hash计算, 加密这个字符串的hash值后发送给“客户”, “客户”收到后解密这个hash值并自己计算字符串的hash值然后进行对比是否一致
  ```

- 问题2:

  ```
  通信过程中 “黑客” 可以截获加密后的内容, 虽然他无法解密这个内容, 但是可以把信息原封不动的发送多次, 扰乱通信过程. 
  
  
  给通信的内容加上一个序号或者一个随机的值, 如果“客户”或者“服务器”接收到的信息中有之前出现过的序号或者随机值, 那么说明有人在通信过程中重发信息内容进行捣乱, 双方会立刻停止通信。
  ```

- 问题3:

  ```
  修改截获后的密文修改后再发送, “客户”和“服务器”是无法判断密文是否被修改
  
  
  发送信息时, 将信息内容和信息内容的 hash 值一起加密后发送, 接收方解密得到信息内容和 hash 值, 接收方再自己 hash 消息内容, 与收到的 hash 值进行对比看是否匹配
  ```

## 数字证书

##### 数字证书分类

<img src=".\image\数字证书分类.jpg" alt="数字证书分类" style="zoom:80%;" />

> https://blog.csdn.net/liuxingrong666/article/details/83869161

##### 证书发布机构

```
1. CA 机构除了给别人颁发证书以外, 它也有自己的证书, 这个证书是机构自己颁发给自己的, 称它为根证书, 根证书也有自己的公钥和私钥, 根公钥和加密算法是对外公布的, 根私钥 CA 机构自己绝对保密, 用这个私钥加密所有他发布的证书的指纹作为数字签名
2. 根证书颁发者和使用者都是一样
3. 所有的公司都可以发布证书, 但不会被那些国际上的权威机构认可的, 当应用程序在检查证书的合法信的时, 发布机构并不是操作系统所信任的发布机构, 会抛出错误信息
```

##### CA 证书签发过程

```
1. 由数字证书需求方产生自己的密钥对
2. 证书申请人产生自己的
2. 由数字证书需求方将算法、公钥和证书申请者身份信息传送给认证机构。
3. 由认证机构核实用户的身份，执行相应必要的步骤，确保请求确实由用户发送而来。
4. 由认证机构将数字证书颁发给用户。

这里的认证机构如果是证书申请者本身，将获得自签名证书。
```



##### 属性

> X.509 格式的证书（X.509 V3）和证书废止列表CRL（X.509 V2 ??????
>
> 

```
Version 版本号: 证书格式可能会不断改进, 版本号给出了证书遵从的格式, 到目前为止共有3个版本, 分别用0、1、2来表示版本1、版本2和版本3. 现在大部分证书都采用版本3的格式, 即用X.509的版本，目前普遍使用的是v3版本（0x2）

Serial Number序列号: 颁发者分配给证书的一个正整数，同一颁发者颁发的证书序列号各不相同，可用与颁发者名称一起作为证书唯一标识
Extensions 证书扩展: 

Issuer: 证书发布机构, 什么机构发布的这个证
Valid from: 有效期
Valid to: 有效期
Public key: 公钥
Subject: 主题, 证书的所有者(个人 / 公司 / 机构/ 网站 等)

Thumbprint: 指纹, 一个 hash 值, 保证证书的完整性的, 确保证书没有被修改过. 证书在发布之前, CA 机构对证书的内容用指纹算法计算得到一个hash值, 这个hash值就是指纹
Thumbprint algorithm: 指纹算法(一般是sha1或sha256)

Signature: 证书签名, 证书在发布的时候, CA 机构将证书的指纹和指纹算法通过自己的私钥加密得到的就是证书的签名. 证明该信息有没有被修改过
Signature algorithm: 签名算法
```

##### 格式

| 格式    |                                                              |
| ------- | ------------------------------------------------------------ |
| PKCS#12 | 以二进制格式保存的证书, 可以包含或不包含私钥. <br />*.P12 *.PRX |
| DER     | 以二进制格式保存的证书, 不包含私钥.<br />*.DER *.CER *.CRT   |
| PEM     | 以 ASCII码格式保存的证书, 可以包含或不包含私钥.<br />*.PEM *.CER *.CRT |

##### ca 证书验证过程

<img src=".\image\证书验证过程.png" style="zoom:50%;" />

```
1. S 向 CA 机构提交信息申请证书(不需要提供私钥);
2. CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;
3. 如信息审核通过, CA 会向申请者签发证书. 
4. C 向 S 发出请求时，S 返回证书文件
5. C 先用操作系统中 ca 机构的根公钥去解密证书(解密成功说明这个证书是 ca 机构私钥加密的, 没有伪造和修改), 解密成功得到证书的指纹和指纹算法. 自己再通过指纹算法计算证书内容的 hash 值, 如果解密获得的 hash 值相同, 则代表证书没有被篡改过. 再验证证书是否合法
	1.证书是否过期。
    2.发行服务器证书的CA是否可靠。
    3.发行者证书的公钥能否正确解开服务器证书的"发行者的数字签名"。
    4.服务器证书上的域名是否和服务器的实际域名相匹配。
6. 如果 C 再系统中找不到对应的 CA 证书, 则证书不被 CA 信任
```

##### 证书撤销

```
1. 原因: 用户名称的改变, 私钥泄露, 业务中止, 超过有效期
2. 撤销证书: 撤销公钥及相关的PKI实体身份信息的绑定关系
3. CA 无法强制收回已经颁发出去的数字证书, 需要维护一个 CRL 来实现证书的作废
4. CRL (Certificate Revocation List) 撤销证书列表, 用于记录已经撤销的证书序号
5. CRL存储库: 用于对 CRL 信息进行存储和管理, 并提供查询功能. 使用 FTP/HTTP/数据库等实现
6. 任何一个证书被撤销以后，CA就要发布CRL来声明该证书是无效的，并列出所有被废除的证书的序列号, 公开对用户发布的电子数据列表, 由 CA 对该列表进行数字签名
7. 通常情况下，当第三方对某个证书进行验证时，需要首先检查该证书是否在撤销列表中。如果存在，则该证书无法通过验证。如果不在，则继续进行后续的证书验证过程
```

##### 证书格式

```
der: 二进制形式, 扩展名 der 和 cer

pem: 一种容器格式, 可以将服务端证书, 中间证书和私钥包含在一个文件中。用于存储和发送加密密钥，证书和其他数据。可能仅包含公钥证书，也可以包含完整的证书链（包括公玥，私钥，和根证书）。

```



```
.DER .CER，文件是二进制格式，只保存证书，不保存私钥。
.PEM，一般是文本格式，可保存证书，可保存私钥。
.CRT，可以是二进制格式，可以是文本格式，与 .DER 格式相同，不保存私钥。
.PFX .P12，二进制格式，同时包含证书和私钥，一般有密码保护。
.JKS，二进制格式，同时包含证书和私钥，一般有密码保护。
```



## pki 标准

> https://www.cnblogs.com/precedeforetime/p/13390761.html
>
> https://www.jianshu.com/p/46a911bd49a7
>
> https://blog.csdn.net/qianlai22/article/details/123402712
>
> https://www.jianshu.com/p/40268795193d

##### 定义

```
1. pki (Public Key Infrastructure) 公钥基础设施, 目的是为指定的 PKI 实体向 CA 申请一个本地证书, 并由设备对证书的有效性进行验证, 方便用户管理证书 
2. PKI 既不是一个协议，也不是一个软件，它是一个标准，在这个标准之下发展出的为了实现安全基础服务目的的技术统称为 PKI
3. PKI系统主要采用的散列算法有SHA一1和MD一5


作用:
为网络安全提供基础设施和服务，包括以下内容
    网络身份认证
    加解密电子数据

保证网络信息的完整性、真实性、可追踪性（不可否认）、保密性、
    完整性：为了防止信息被篡改，对应的密码技术有单向散列函数、 消息认证码、 数字签名。
    机密性：为了防止信息被窃听，对应的密码技术有对称密码和 公钥密码。
    真实性：为了防止攻击者伪装成真正的发送者，对应的密码技术有消息认证码和数字签名。
    可追踪性：为了防止发送者事后否认自己没有做过，对应的密码技术为数字签名
	(完整保密真实可追踪)
```

##### 证书管理

```
证书签核和更新
证书注销/撤销/吊销
证书冻结和解冻
证书下载查询
...
黑名单登记和黑名单发布?
时间戳服务?
```

##### 信任模型

```
https://zhuanlan.zhihu.com/p/520328317
```

##### 体系结构

> https://www.jianshu.com/p/40268795193d

<img src=".\image\PKI体系结构.png" style="zoom:80%;" />

```
1. EE (End Entity): 终端实体也称为PKI实体. 它是PKI产品或服务的终使用者，可以是个人、组 织、设备（如路由器、防火墙）或计算机中运行的进程
2. CA: 负责证书的颁发和吊销, 接收来自 RA 的请求
3. RA (Registration Authority): 注册机构, 负责接受用户的证书注册和撤销申请, 对用户的身份信息进行审查, 并决定是否向 CA 提交签发或撤销数字证书的申请. RA 作为 CA 功能的一部分 RA 并不一定独立存在而是和CA合并在一起. RA 也可以独立出来分担CA的一部分功能减轻CA的压力, 增强CA系统的安全性
4. 证书存储库：存储已签发的数字证书和公钥，以及相关证书目录，用户可由此获得所需的其他用户的证书及公钥.
5. CRL
6. OCSP: 获得证书状态的国际协议
7. API: 功能密码运算, 证书验证和解码, 证书和CRL的获取和存储, 通信消息处理
    (1)PKCS #11，由RSA公司制定的密码设备接口标准，用于密码设备管理等
    (2)Microsoft cryptoAPI，由微软定义，用于Windows操作系统，需要使用CSP（即Cryptographic Service Provider）
    (3)openssl, 纯软件实现，主要接口功能
        各种堆成密码算法
        x.509证书和CRL编解码和验证，及其扩展
        公钥密码算法相关数据格式标准
        SSL/TLS协议的会话协商和数据传输
```



```
X.509证书是通用的PKI数字证书格式
```

## pmi

```
pmi (Privilege Management Infrastructure)

PMI仅仅使用公钥技术但并不管理公开密钥
```

```

```

