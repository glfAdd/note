HTTP协议Host请求头的作用

1. Host 是 HTTP 1.1 协议中新增的一个请求头，主要用来实现虚拟主机技术。
2. 虚拟主机（virtual hosting）即共享主机（shared web hosting），可以利用虚拟技术把一台完整的服务器分成若干个主机，因此可以在单一主机上运行多个网站或服务。
3. 同一个IP也可以设置多个不同站点，那我访问不同的域名都转发到同一IP，怎么区分这些不同的站点呢，就是用的Host字段，如果服务器后台解析出Host但是服务器上找不到相应的站点，那么这个连接很可能会被丢弃，从而报错.


在Nginx中, server name是指在Nginx配置文件中，在server块中，用server_name指令设置的值。一个server可以多次使用server_name指令，来实现俗称的“虚拟主机”。例如：

server {
    listen      80;
    server_name example.org www.example.org;
    ...
}

server {
    listen      80;
    server_name example.net www.example.net;
    ...
}

server {
    listen      80;
    server_name example.com www.example.com;
    ...
}

关于虚拟主机的确定方法，还是引用Nginx的官方文档：
在这个配置中，nginx仅仅检查请求的“Host”头以决定该请求应由哪个虚拟主机来处理。
如果Host头没有匹配任意一个虚拟主机，或者请求中根本没有包含Host头，那nginx会将请求分发到定义在此端口上的默认虚拟主机。
在以上配置中，第一个被列出的虚拟主机即nginx的默认虚拟主机——这是nginx的默认行为。而且，可以显式地设置某个主机为默认虚拟主机，即在”listen”指令中设置”default_server”参数：

server {
    listen      80 default_server;
    server_name www.test.info
}
****************************************************
get 和 post 区别, 如何选择

相同点:
    1. 如果我告诉你 GET 和 POST 本质上相同
    2. GET 和 POST 的底层也是 TCP/IP. 你要给 GET 加上 request body，给 POST 带上 url 参数，技术上是完全行的通的, 只要服务端和客户端约定好就行
    3. 但是由于 HTTP 的规定和浏览器 / 服务器的限制，导致他们在应用过程中体现出一些不同

区别:
    1. GET产生一个TCP数据包, POST产生两个TCP数据包。
    2. 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。
    3. 对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。
    4. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。


HTTP协议明确地指出了，HTTP头和Body都没有长度的要求，URL长度上的限制主要是由服务器或者浏览器造成的
在用法上，一个用于获取数据，一个用于修改数据；
在根本上，没有啥区别

****************************************************
http 和 https
区别
如何使用

****************************************************
hbase 和 mongodb
1.
区别
选择


****************************************************
kafka 和 rabbitmq

适用场景
    rabbitMQ: 支持对消息的可靠的传递，支持事务，不支持批量的操作；基于存储的可靠性的要求存储可以采用内存或者硬盘。
    kafka: 具有高的吞吐量, 内部采用消息的批量处理


架构方面
    kafka遵从一般的MQ结构，producer，broker，consumer


消费失败重试
    Kafka: 消费失败不支持重试
    RocketMQ: 消费失败支持定时重试，每次重试间隔时间顺延
    总结：例如充值类应用，当前时刻调用运营商网关，充值失败，可能是对方压力过多，稍后在调用就会成功，如支付宝到银行扣款也是类似需求。



消息查询
    Kafka: 不支持消息查询
    RocketMQ: 支持根据Message Id查询消息，也支持根据消息内容查询消息（发送消息时指定一个Message Key，任意字符串，例如指定为订单Id）
    总结：消息查询对于定位消息丢失问题非常有帮助，例如某个订单处理失败，是消息没收到还是收到处理出错了。



消息回溯
    Kafka: 理论上可以按照Offset来回溯消息
    RocketMQ: 支持按照时间来回溯消息，精度毫秒，例如从一天之前的某时某分某秒开始重新消费消息
    总结：典型业务场景如consumer做订单分析，但是由于程序逻辑或者依赖的系统发生故障等原因，导致今天消费的消息全部无效，需要重新从昨天零点开始消费，那么以时间为起点的消息重放功能对于业务非常有帮助。

****************************************************
数据削峰填谷的利器




****************************************************
flask 原理



****************************************************


生成器
迭代器
匿名函数
装饰器
with
open
yield
yield from

多线程
多进程
GIL
mysql




getattr和getattribute


