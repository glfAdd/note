# hash

##### hash 表的结构

<img src=".\image\hash表的结构.png" alt="hash表的结构" style="zoom:80%;" />



```
1. Hash table (哈希表 或 散列表)
2. key (键) 通过一个固定算法函数 (hash 函数) 把 key 转换成一个整型数字, 然后用该数字与数组长度取余, 取余结果当作数组的下标, 将 value 存储在以该数字为下标的数组空间里 ,存放记录的数组叫做散列表
3. 当用 hash 表查询时, 就是使用 hash 函数将 key 转换成对应的数组下标, 并定位到该下标的数组空间里获取 value, 这样就充分利用到数组的定位性能进行数据定位

hash 函数 (散列函数): 存在一种函数 F, 根据这个函数和 key, 可以直接确定查找值所在位置, 而不需要一个个遍历. 即地址 index = F(key)
hash 值: key 通过 hash 函数算出的值 (对数组长度取模，便可得到数组下标)
hash函数就是根据key计算出该存储地址的位置，hash 表就是基于hash函数建立的一种查找表

hash函数：记录的关键字和存储位置建立映射关系
对应关系f（）称为散列函数，或者哈希函数
如举例子中的 f(x) = x % 5;
哈希函数是一种映射关系
```

## hash 冲突

##### 是什么

```
1. 通过 hash 函数计算时, 不同的 key 值得到相同的 value
2. 性能良好的 hash 函数可以减少冲突, 但一般不可能完全避免冲突
```

### 解决冲突的方法

#### 开放定址法

```
开放定址法：是一旦发生了冲突，就去寻找下一个空的散列地址
f(key)=(f(key)+d) mod m。
只要散列表足够大，空的散列地址总能够找到，并将其记录存入。
a.d=1,2,3……m-1时，称为线性探测再散列。
b.d=12,-12,22,-22,……(-)k^2时，称为二次线性再散列。
c.d为伪随机序列时，称为伪随机序列再散列。
```

#### 再散列函数法

```
：f(key)=RH(key),RH()为不同的哈希函数，即在地址冲突的时计算另一个哈希函数地址，直到不发生冲突为止。
```

#### 链地址法（又称链接法/拉链法/哈希桶）

```
1. 将所有哈希值冲突的记录存储在同一个线性链表中
2. 查找 key 的时候, 通过 key 索引到对应的桶, 然后从桶的链表顺序查找. 
3. hash 冲突率高的时候, 桶内的链表就会很长, 使得查找效率比较低. 最坏的情况下, 所有 key 都对应同一个 hashvalue, 那么哈希表变成了单链表, 将查找效率从 O(1) 直接降到了 O(N). (解决办法, 用红黑树代替单链表)
```

##### 桶结构

```c
typedef struct tagHASH_BUCKET {
	int iHashBucketSize; 			// 桶大小, 如 1024
	int (*pfHash)(const void *); 	// 哈希计算函数, 如简单的 y = 3x +1 (key=1时，value = 4 value就是索引) 
	SinList *pstBucket; 			// 桶的单链表
}
```

<img src=".\image\hash冲突.webp" alt="hash冲突" style="zoom:50%;" />

```
例如, 设置 10 个桶, 也就是f(key)集合的个数, hashvalue 作为桶的索引
10 通过 f(key) 得到 hashvalue 值为 0, 作为索引放到桶 0 的首地址所指的内存中
11 通过 f(key) 得到 hashvalue 值为 1, 作为索引放到桶 1 的首地址所指的内存中
21 通过 f(key) 得到 hashvalue 值为 1, 但桶1的首地址已经有了元素11
```





#### 公共溢出区法

```
将所有的哈希地址冲突的记录都填入到溢出表中。
```



## hash 算法

##### 直接定址法

```
f(key)=a*key+b
取关键字的某个线性函数作为散列（哈希）地址, 但需要知道关键字的分布，现实情况很少用
```

##### 数字分析法

```
对于刚刚入学的童鞋都会有个学号，而前几位肯定相同，后面几位每个人都不同，这时（不用）分析便可知道，抽取后面几位，对这些数字进行操作，使之不相同，总而言之就是提供一个哈希函数，能够让关键字分配到哈希表中去

取关键字中若干位作为哈希地址。例如手机号中间四位为归属地
```

##### 平方取中法

```
也就是说将数字平方，取中间几位作为关键字。
取关键字平方后的中间几位作为哈希地址。例如1234 平方后为1522756，取其中的三位就是227。
```

##### 除数取余法 (最常用)

```
假如你有n个数字
f(key)=key%p（p=<n）
也可平方后操作，当然这里关键在于找到合适的p


f(key)=key mode p (p<=m) m 为不大于哈希表的数。
    如f(x) = x % 5
```

##### 随机数法

```
取随机数作为散列地址
f(key)=random(key)
就是用了random函数

然而事实情况是：构建这样的函数很难，所以要去解决这种冲突
也就是解决key1不等于key2，但f(key1)=f(key2)。
```

##### 开发定址法

##### 再散列函数法

##### 链地址法

##### 折叠法

```
将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为哈希地址。
例如：9876543210 分为987 654 321 0 求和为1962 再取三位得到散列地址：962。
除留余数法(最常用)：
```

## 红黑树

# 参考

- [ ] https://juejin.cn/post/6844903769361088526
- [ ] 