##### 索引类型

```
FULLTEXT
全文索引，目前只有MyISAM引擎支持。不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。
全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%"这类针对文本的模糊查询效率较低的问题。


HASH 		
由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。
HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。


BTREE 
是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。


RTREE 
在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。
相对于BTREE，RTREE的优势在于范围查找.


逻辑上: 单列索引, 多列索引, 唯一索引, 非唯一索引
物理上: 聚簇索引, 非聚簇索引
```

##### 几种树结构

```
树: 最上一层是根节点.最底下一层是叶子节点.(一般左边节点小于右边节点)

二叉树: 每个节点最多只能有两个分支,一般只用于教材.二叉树的深度不可控,造成遍历数据时IO次数不可控.数据量大了,树的深度会太大.

二叉树的变种: BTREE(又写成B-tree),B+tree和B*tree.

B-tree即balance-tree: 平衡树:假设1个节点的子节点是5个,平衡树是必须上层节点都满了,才可加到下层.这样树的深度就得到了控制.B-tree除了在叶子节点保存数据,在非叶子节点也保存数据.

B+tree: 所有数据都存储在叶子节点,非叶子节点不存储数据.且叶子节点间构成了双向链表。Mysql用的方法是B+tree.

b+tree的插入必须要保证插入后，叶子节点的数据依然有序。而且不管怎么变化，根节点到叶子节点的深度始终是相同的。

B*tree:也只在叶子节点存储数据并构成双向指针,但在非叶子节点有双向指针。
```

# 聚簇索引

##### 聚簇索引表

```
innodb将表结构数据存储在一个B+TREE中,B+TREE叫聚簇索引(cluster-index).
以聚簇索引构建的表叫聚簇索引表,又称索引组织表, 表结构本身就是索引。
聚集索引页的叶子节点汇总存放着完整的记录，副主索引页中存放着指向叶子的指针。
聚集索引是通过将表的主键作为键值来构造B+树的,因为innoDB存储引擎是通过主键来构造的,所以这需要每一张表都有主键,如果没有显式的指定主键,那么数据库是自动创建主键,聚集索引不仅仅包含索引的键值,还包含了记录所在其他列的值,聚集索引中的记录是根据键值顺序排列的,但是不是物理排序,而是顺序排序。
说明：

1. 根据主键寻址速度很快
2. 主键值递增的insert插入效率较好
3. 主键值随机insert插入操作效率差
```

##### 聚簇索引构建规则

```
1. 有主键, 用主键来构建聚簇索引.
2. 没有主键, 如果有唯一性非空索引,就用该索引构建.
3. 都没有, 则开辟一个6字节的隐藏列,用隐藏列构建主键索引.
```

##### 哪些情况下建议创建索引

```
经常搜索的列
经常用在表连接的列
经常需要排序的列
经常使用在WHERE子句中的列
```

##### 辅助索引

```
1. 辅助索引又称二级索引或非聚簇索引.
2. 辅助索引也是B+tree,叶子节点存放的是索引列和主键值,不存放其他列信息.若无主键,则存放的是索引列和该表聚簇索引的虚拟主键值.辅助索引是根据索引列的值排序.
3. 在聚簇索引和辅助索引都存在的时候，优化器倾向于使用聚簇索引，因为聚簇索引可以通过叶子节点找到数据。
4. 通过辅助索引查询记录仅仅只能得到主键值，要查询完整的记录，还需要通过一次聚簇索引查询。（回表）
5. 聚簇索引通常比辅助索引的高度要高（辅助索引不保存所有记录，更小，高度更低）。
```

##### 覆盖索引

```
一个查询语句的执行只需要从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。
特高频SQL，强烈推荐使用覆盖索引，可以非常大的提高查询效率。
```

##### 回表

```
指当通过辅助索引查询得到的记录信息不足,需要回表再通过聚簇索引查询信息
```

##### 复合索引

```
建立在多个列上的索引
遵从最左前缀原则
```

##### 索引下推

```
索引下推: ICP(Index Condition Pushdown)
它能减少使用二级索引过滤where条件时的回表次数

不使用ICP, 通过二级索引进行查询，存储引擎通过索引检索数据，然后返回给MySQL服务器，MySQL服务器再判断是否符合条件。

使用ICP，当存在索引的列做为判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。
```

##### 索引失败原因

```
不在索引的列上做任何计算, 函数或类型转换, 避免隐式类型转换

不等于 != 和 <> 无法使用索引

is null 和 is not null 导致索引失败

like 使用 % 开头

or 用它连接时索引会失效
```



```sql
-- 范围条件后列上索引失效
explain select * from student where age > 1 and name = '王五';

-- 使用不等于（！= 或者<>）不能使用索引
explain select * from student where name != '张三';

-- 使用 is null 或者 is not null 也不能使用索引
explain select * from student where name is not null;

-- like 已通配符开头（%abc）导致索引失效 （解决方法：使用覆盖索引）
explain select * from student where name like '%张%';
-- 想用的话解决方法，使用覆盖索引
explain select name from student where name like '%张%';
```

# 最左前缀匹配原则

```
mysql创建的联合索引会遵守这个规则
```

```
1. MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序
```

##### 联合索引最左匹配原则

```
https://bbs.huaweicloud.com/blogs/169243
```


##### EXPLAIN

- type

  - ALL: 遍历全表以找到匹配的行
  - index: Index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取
  - range: 只检索给定范围的行，使用一个索引来选择行。key列显示使用了那个索引。一般就是在where语句中出现了bettween、<、>、in等的查询。这种索引列上的范围扫描比全索引扫描要好。只需要开始于某个点，结束于另一个点，不用扫描全部索引
  - ref: 非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体
  - const: 表示通过索引一次就找到了，const用于比较primary key 或者 unique索引。因为只需匹配一行数据，所有很快。如果将主键置于where列表中，mysql就能将该查询转换为一个const

- key_len: 显示MySQL实际决定使用的索引的长度

  

```
计算规则：
1.定长字段，int占用4个字节，date占用3个字节，char(n)占用n个字符。
2.变长字段varchar(n)，则占用n个字符+两个字节。
3.不同的字符集，一个字符占用的字节数是不同的。Latin1编码的，一个字符占用一个字节，gdk编码的，一个字符占用两个字节，utf-8编码的，一个字符占用三个字节。
（由于我数据库使用的是Latin1编码的格式，所以在后面的计算中，一个字符按一个字节算）
4.对于所有的索引字段，如果设置为NULL，则还需要1个字节。
```

##### 联合索引最左前缀匹配原则

- MySQL中有查询优化器explain，所以sql语句中字段的顺序不需要和联合索引定义的字段顺序相同，查询优化器会判断纠正这条SQL语句以什么样的顺序执行效率高，最后才能生成真正的执行计划
- 可以根据key_len推算使用的哪个索引

```
示例: 创建 age_name_address 的联合索引相当于创建了3个索引, age, age_name, age_name_address

# 1. 只使用age索引, (可以看key_len长度)
EXPLAIN select * from person WHERE age=11;
# (不是依次匹配, 所以只用到了索引age)
EXPLAIN select * from person WHERE age=11 and address='china';

# 2. 只使用 age_name 索引
EXPLAIN select * from person WHERE name='tom' and age=11;

# 3. 使用 age_name_address 索引
(
通过观察发现上面key字段发现在搜索中也使用了id_name_age_index索引，可能许多同学就会疑惑它并没有遵守最左匹配原则，按道理会索引失效，为什么也使用到了联合索引？因为没有从id开始匹配，且name单独来说是无序的，所以它确实不遵循最左匹配原则，然而从type字段可知，它虽然使用了联合索引，但是它是对整个索引树进行了扫描，正好匹配到该索引，与最左匹配原则无关，一般只要是某联合索引的一部分，但又不遵循最左匹配原则时，都可能会采用index类型的方式扫描，但它的效率远不如最做匹配原则的查询效率高，index类型类型的扫描方式是从索引第一个字段一个一个的查找，直到找到符合的某个索引，与all不同的是，index是对所有索引树进行扫描，而all是对整个磁盘的数据进行全表扫描。
)
EXPLAIN select * from person WHERE name='tom';
EXPLAIN select * from person WHERE address='china';
EXPLAIN select * from person WHERE name='tom' and address='china';
EXPLAIN select * from person WHERE name='tom' and address='china' and age=11;


# 前缀都是排好序的，使用的都是联合索引
select * from staffs where age like 'A%';
# 全表查询
select * from staffs where age like '%A%';
# 全表查询
select * from staffs where age like '%A';


# age精确匹配, name范围匹配
# (age范围内name是无序的所以只用了age索引)
```

##### 单列索引

```
https://www.jianshu.com/p/7850b14c9e35

有三个单列索引 age name address

# 多个单列索引在多条件查询时优化器会选择最优索引策略，可能只用一个索引，也可能将多个索引全用上！ 但多个单列索引底层会建立多个B+索引树，比较占用空间，也会浪费一定搜索效率，故如果只有多条件联合查询时最好建联合索引！
EXPLAIN select * from person WHERE name='tom' and address='china' and age=11;
# or 连接用到了所有索引
EXPLAIN select * from person WHERE name='tom' or address='china' or age=11;
```

##### 单独索引和联合索引同时存在时

```
优先使用单独索引，单独索引里有重复项时才用到联合索引
能用单独索引时，MySQL会认为没必要用到组合索引

当同时存在单列索引和联合索引，mysql会根据查询优化策略选择其中一个索引。
```

# 问题

##### 影响查询速度的因素

```
sql查询速度
网卡流量
磁盘IO
服务器硬件性能
```



















