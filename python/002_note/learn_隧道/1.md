参考

```
https://www.cnblogs.com/bakari/p/10564347.html
```



# 其他

##### 用户空间与内核空间的数据传输

```
Linux 中用户空间和内核空间的数据传输有多种方式，字符设备就是其中的一种
```

### IP 数据包



# 网卡

#### 物理网卡设备

物理网卡: 它一边是内核空间的网络协议栈，另一边是外界网络, 物理网卡连接这两者, 以01形式的比特流收发数据的硬件设备.



<img src=".\image\物理网卡.jpg" alt="物理网卡" style="zoom:80%;" />



物理网卡需要通过网卡驱动在内核中注册后才能工作, 用户可以为物理网卡配置网卡接口属性, 如 IP 地址, 这些都配置在内核的网络协议栈中.

用户进程和网卡传输过程:

<img src=".\image\用户进程和物理网卡传输.jpg" alt="用户进程和物理网卡传输" style="zoom:80%;" />

```
1. 用户进程发送数据时，数据从用户空间写入到内核的网络协议栈，再从网络协议栈传输到网卡，最后发送出去
2. 用户进程等待外界响应数据时，数据从网卡流入，传输至内核的网络协议栈，最后数据写入用户空间被用户进程读取
3. 内核和用户空间的数据传输, 由内核占用 CPU 来完成
4. 内核和网卡之间的数据传输, 由网卡的 DMA 来完成, 不需要占用过多的 CPU
```

#### 虚拟网卡设备

<img src=".\image\虚拟网卡.jpg" alt="虚拟网卡" style="zoom:80%;" />

1. 内核可以直接创建虚拟网卡, 只要为虚拟网卡提供网卡驱动程序，使其在内核中可以注册成为网卡设备，它就可以工作
2. 虚拟网卡两端是内核的网络协议栈和用户空间, 它只负责在内核网络协议栈和用户空间的程序之间传递数据
   1. 发送到虚拟网卡的数据来自于用户空间，然后被内核读取到网络协议栈中
   2. 内核写入虚拟网卡，准备通过该网卡发送的数据，目的地是用户空间
3. 虚拟网卡可以将数据传输到本机的另一个虚拟网卡/ 物理网卡 / 虚拟交换机 等其他虚拟设备上
4. 可以在用户空间运行一个可读写虚拟网卡的程序，该程序可将流经虚拟网卡的数据包进行处理，比如OpenVPN
5. 用户空间的程序是无法直接对数据包做任何封装和解封操作的，只能通过内核的网络协议栈来完成封装和解封后使用数据包

#### 物理/虚拟网卡区别

1. 物理网卡是硬件设备, 位于硬件层; 虚拟网卡可以看作是用户空间的网卡
2. 内核对物理网卡和虚拟网卡可配置的属性相同, 比如都可以配置IP地址、设置子网掩码，可以将虚拟网卡接入网桥等等
3. 只有在数据流经物理网卡和虚拟网卡的那一刻才会体现出它们的不同, 
   1. 物理网卡以比特流的方式和外界传输数据
   2. 虚拟网卡在内存中拷贝数据(在内核之间和应用程序之间传输数据)
4. 物理网卡能够直接收发外界的数据. 虚拟网卡不具备物理网卡以比特流方式传输数据的硬件功能, 所以无法通过虚拟网卡向外界发送数据, 外界数据也无法直接发送到虚拟网卡上.

# tun 和 tap

##### tun 和 tap 是什么

1. 都是是虚拟网络网卡, 完全由软件来实现, 功能和硬件实现完全没有差别, 都可以配置属性, 由 Linux 网络设备管理模块统一管理
2. tap 等同于一个以太网设备，它操作第二层数据包, 如以太网数据帧
3. tun 模拟了网络层设备，操作第三层数据包, 如 IP 数据封包

##### 应用程序如何与 tun 和 tap 交互

<img src=".\image\tap和tun原理.webp" alt="tap和tun原理" style="zoom:80%;" />

- 应用程序与 tun/tap 交互需要通过驱动

- 应用和驱动的交互方式
  - 虚拟网络接口: 通过 Socket API 调用接口发送数据给驱动, 同时这些数据包会被原样写入数据到字符设备
  - 字符设备: 写入数据到字符设备, 同时这些数据包会被原样发送到虚拟接口上

- Linux 内核 2.6.x 后字符设备分别为:
  - tap：/dev/tap0
  - tun：/dev/net/tun

```

```

##### 问题

```
IP 数据包
ARP
ICMP


Tun虚拟设备和物理网卡的区别是Tun虚拟设备是IP层设备，从/dev/net/tun字符设备上读取的是IP数据包，写入的也只能是IP数据包，因此不能进行二层操作，如发送ARP请求和以太网广播。
Tap虚拟设备是以太网设备，处理的是二层以太网数据帧，从/dev/net/tun字符设备上读取的是以太网数据帧，写入的也只能是以太网数据帧
```



```

3. tap 和 tun 也需要配套相应的驱动程序才能工作, tap 和 tun 驱动程序包括两个部分: 
    一个是字符设备驱动, 负责数据包在内核空间和用户空间的传送
    一个是网卡驱动, 负责数据包在 TCP/IP 网络协议栈上的传输和处理
4. tun 设备的最大用途就是用于隧道通信



tap 和 tun 通过驱动程序和一个与之关联的字符设备，来实现用户空间和内核空间通信接口
在 Linux 内核 2.6.x 之后的版本中，tap/tun 对应的字符设备分别为
    tap：/dev/tap0 (这是个文件)
    tun：/dev/net/tun (这是个文件)

字符设备作为用户空间和内核空间通信的接口, 像一个管道，一端连接着用户空间，一端连接着内核空间
当应用程序打开设备文件时，驱动程序就会创建并注册相应的虚拟设备接口，一般以 tunX 或 tapX 命名
当应用程序关闭设备文件时，驱动自动删除 tunX 和 tapX 设备，还会删除已经建立起来的路由等信息

当用户程序向字符设备写数据时, 内核就可以从对应的 tunX 或 tapX 接口读到数据
反之，内核可以通过相反的方式向用户程序发送数据




操作系统通过TUN/TAP设备向绑定该设备的用户空间的程序发送数据，
反之，用户空间的程序也可以像操作硬件网络设备那样，通过TUN/TAP设备发送数据, TUN/TAP设备向操作系统的网络栈投递（或“注入”）数据包，从而模拟从外部接受数据的过程。
```



```
TUN
TUN 模拟的是一个三层设备，通过它可以处理来自网络层的数据，也就是可以直接处理IP数据包。因此TUN没有 MAC 地址，只能工作在 IP 层，无法与物理网卡做桥转发。

TAP
TAP 设备是一个二层设备，可以收发 MAC 层数据包，即数据链路层，拥有 MAC 层功能，可以与物理网卡做桥转发，支持 MAC 层广播。并且可以给TAP设备配置IP地址。TAP的表现更像一个物理网卡。

```







### vpn

<img src=".\image\vpn数据2.webp" alt="vpn数据2" style="zoom:80%;" />

<img src=".\image\vpn数据.png" alt="vpn数据" style="zoom:80%;" />

VPN 软件通常使用TUN 设备，通过配置静态路由的方式将指定网段的用户数据指向tun设备，VPN 软件获取报文后，进行封装/修改将数据从物理网卡发出。回来的数据VPN 软件从协议栈中获取数据解封装得到IP层数据，在通过TUN写回网络协议栈中，协议栈通过socket 返回给用户APP

```
应用程序可以通过标准的 Socket API向Tun/Tap接口发送IP数据包
```



### tap 应用

```
TAP 接口的典型应用场景是在虚拟化网络中。例如，我们通过KVM创建的多个 VM（虚拟机），以 LinuxBridge（桥接网络）互通；实际上即是通过像 vnet0 这样的 TAP 接口来接入 LinuxBridge 的。 在这种场景下，KVM程序 就是向 TAP 接口读写数据的用户空间程序。当 VM0 向本机的 eth0 接口发送数据，KVM 会将数据发送到 TAP 接口 vnet0 ，再通过 LinuxBridge 将数据转发到 vnet1 上。然后，KVM 将数据发送到 VM1 的 eth0 口。
```

<img src=".\image\tap用于kvm虚拟机.jpg" alt="tap用于kvm虚拟机" style="zoom:80%;" />

### 隧道

#### linux 支持隧道模式

```bash
[root@localhost ~]# ip tunnel help
Usage: ip tunnel { add | change | del | show | prl | 6rd } [ NAME ]
          [ mode { ipip | gre | sit | isatap | vti } ] [ remote ADDR ] [ local ADDR ]
          [ [i|o]seq ] [ [i|o]key KEY ] [ [i|o]csum ]
          [ prl-default ADDR ] [ prl-nodefault ADDR ] [ prl-delete ADDR ]
          [ 6rd-prefix ADDR ] [ 6rd-relay_prefix ADDR ] [ 6rd-reset ]
          [ ttl TTL ] [ tos TOS ] [ [no]pmtudisc ] [ dev PHYS_DEV ]

Where: NAME := STRING
       ADDR := { IP_ADDRESS | any }
       TOS  := { STRING | 00..ff | inherit | inherit/STRING | inherit/00..ff }
       TTL  := { 1..255 | inherit }
       KEY  := { DOTTED_QUAD | NUMBER }
```

```
ipip: IPv4 in IPv4，在 IPv4 报文的基础上再封装一个 IPv4 报文
gre: 通用路由封装（Generic Routing Encapsulation），定义了在任意一种网络层协议上封装其他任意一种网络层协议的机制，IPv4 和 IPv6 都适用。
sit: 和 ipip 类似，不同的是 sit 是用 IPv4 报文封装 IPv6 报文，即 IPv6 over IPv4。
isatap: 即站内自动隧道寻址协议（Intra-Site Automatic Tunnel Addressing Protocol），和 sit 类似，也是用于 IPv6 的隧道封装。
vti: 即虚拟隧道接口（Virtual Tunnel Interface），是 cisco 提出的一种 IPsec 隧道技术。
```

#### ipip

```
加载 ipip 模块后，就可以创建隧道了，方法是先创建一个 tun 设备，然后将该 tun 设备绑定为一个 ipip 隧道即可
```



```
 tun 常常被用来做隧道通信（tunnel）
 Linux 原生支持多种三层隧道，其底层实现原理都是基于 tun 设备
```

```
两个应用程序 A、B
物理网卡 eth0(10.1.1.11)
虚拟网卡 tun0(192.168.1.11)


0. A 希望数据包发往 192.168.1.0/24 网段的主机 192.168.1.1
1. A 构造数据包, 目的是 192.168.1.1, A 通过 socket 将这个数据包发给协议栈
2. 协议栈根据数据包的目的 IP 地址匹配路由规则, 发现要从 tun0 出去
3. tun0 发现自己的另一端被 B 打开了, 于是将数据发给 B
4. B 收到数据后做了一些跟业务相关的操作后构造一个新的数据包, 源 IP 是 eth0 的 IP, 目的 IP 是 10.1.1.0/24 的网关 10.1.1.1，封装原来的数据的数据包，重新发给协议栈
协议栈再根据本地路由，将这个数据包从 eth0 发出

当 10.1.1.1 收到数据包后，会进行解封装，读取里面的原始数据包，继而转发给本地的主机 192.168.1.1。当接收回包时，也遵循同样的流程。

在这个流程中，应用程序 B 的作用其实是利用 tun0 对数据包做了一层隧道封装。
```

