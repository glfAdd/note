# 说明

```
Python3.9 源代码

源代码在 Objects/obmalloc.c
```

# 堆栈

<img src=".\image\CPython内存堆栈.webp" alt="CPython内存堆栈" style="zoom:100%;" />

```
堆: 存储 CPython 运行时的所有对象实体
栈: 存储堆中对象实体的引用


例如
a = 'Hello Word'
'Hello Word' 是字符串对象 PyASCIIObject
CPython 会将对象实体存储到堆内存中, 
对象实体的内存地址压栈存储, 而不是将 'Hello Word' 这个字符串值压入栈, 将地址赋值给变量 a


Python 对象都由 CPython 的 C 底层由一个叫 struct PyObject 结构体所封装. 这个结构体在 CPython 运行时存储在堆内中
```

##### 可变对象 / 不可变对象

```
可变对象: list, dict, 其内部元素可修改, 修改的是引用
不可变对象: 基本数据类型 int, float, str, byte 
```

# CPython 内存结构

<img src=".\image\CPython内存架构.webp" alt="CPython内存架构" style="zoom:100%;" />

![CPython内存架构3](.\image\CPython内存架构3.webp)

```
python 管理 1, 2, 3 层
c 库管理 0 层
操作系统管理 -1, -2
```

- 第 3 层

```
对象缓冲池
python 内置基本类型（int, dict等）都有独立的私有内存池, 对象之间的内存池不共享, 即int释放的内存, 不会被分配给float使用
```

- 第 2 层

```
内存池
小内存使用内存池进行分配, 申请的内存小于256KB时
实现了 创建/销毁 Python 对象的接口 (PyObject_New/Del)
```

- 第 1 层

```
当申请的内存大于256KB时, 由 Python 原生的内存分配器进行分配, 本质上是调用 C 标准库中的 malloc/realloc 等函数
是 PyMem 内存分配函数, 它确保 CPython 运行时, 堆中有足够可用的堆内存, 如果没有, 它会向下一层请求更多的内存.



1. 包装了第 0 层的内存管理接口, 提供统一的 raw memory 管理接口
2. 不同操作系统 C 行为不一定一致, 保证可移植性, 相同语义相同行为
3. PyMem_ API 是对操作系统内存管理接口进行的封装

```

- 第 0 层

```
C 库中的 malloc, free 等函数直接和操作系统的虚拟内存管理器交互, 分配和释放内存
并且接受来自上一层 PyMem 内存分配函数的内存空间请求, 以及将系统分配的内存空间返回给上一层 PyMem


操作系统提供的内存管理接口, 由操作系统实现并管理
```

- 第 -1 层

```
虚拟内存管理原理
基于页表的虚拟内存管理器, 以页 ( page )为单位管理内存, CPU 内存管理单元( MMU )在这个过程中发挥重要作用
```

- 第 -2 层

```
操作系统进行操作
底层存储设备, 直接管理物理内存以及磁盘等二级存储设备
```

## 内存管理架构

![L1内存管理](.\image\L1内存管理.webp)

```
PyMem_* 位于 CPython 内存模型第1层
_PyObject_* 函数族衔接第1层和第2层的
```

```c
typedef struct {
    // 用户上下文作为第一个参数
    void *ctx;
    // 分配一块内存
    void* (*malloc) (void *ctx, size_t size);
    // 分配以零初始化的内存块
    void* (*calloc) (void *ctx, size_t nelem, size_t elsize);
    // 分配或调整内存块大小
    void* (*realloc) (void *ctx, void *ptr, size_t new_size);
    // 释放内存块
    void (*free) (void *ctx, void *ptr);
} PyMemAllocatorEx;


static PyMemAllocatorEx _PyMem_Raw = {
    NULL,
    _PyMem_RawMalloc,
    _PyMem_RawCalloc,
    _PyMem_RawRealloc,
    _PyMem_RawFree
};
```

## 大对象和小对象

![L1和L2交互](.\image\L1和L2交互.webp)

```
Python3 中默认的小内存与大内存的分界点是512字节


大对象:
1. 大于512字节的 Python 对象
2. Arenas 对象 256KB 就是 CPython 的大对象, 此时给 Arenas 大对象的内存分配, CPython 会调用第 0 层 C 库的 malloc 分配器为其分配内存(PyMem_RawMalloc 或 PyMem_RawRealloc)
因此 C 底层的 malloc 分配器是仅供给 arenas 对象使用的


小对象:
1. 小于等于 512 字节的 Python 对象
2. PyObject_Malloc 会在内存池中申请内存


申请 28字节的内存时, Python 内部会在内存池寻找一块能满足需求的 pool, 并从中取出一个 32 字节的 block, 而不会去需找arena



python 的内存分为大内存和小内存, 以256字节为界限
    小内存的对象, 使用内存池进行分配, 不调用 free 函数释放内存, 下次继续使用
    大内存的对象, 使用 malloc 函数分配内存, free 函数释放内存
```

## 对象缓冲池

##### 整数对象缓冲池

```
1. [-5,257] 范围内的小整数, 系统已经初始化好, 可以直接用
2. 其他的大整数, 系统提前申请了一块内存空间, 等需要的时候在这上面创建大整数对象
```

##### Intern 机制 (字符串驻留机制)

1. intern 机制在系统中建立一个 (key,value) 映射关系的集合, 记录着被 intern 机制处理过的 PyStringObject 对象, intern 之后的字符串, 在整个 Python 运行时只有唯一的 PyStringObject 对象与该字符串对应.
2. 如果集合中 PyStringObject  对象已经存在, 则直接返回. 如果不存在则创建 PyStringObject  对象后保存到集合.
3. 只允许由 数字 / 字母 /下划线 组成的字符串, 不能超过20个字符

##### 256 个 ASCII 码进行了对象缓冲池

```

```

##### List 和 Dict 对象缓冲池

```

```

## 内存池

##### 作用

```
1. 避免频繁地申请、释放内存空间(malloc 与 free)导致性能降低;
2. 避免频繁分配与释放小块的内存会产生内存碎片导致降低内存利用效率	

Python 对象都有一个引用计数器, 当引用计数为0时, 被引用的 Python 对象就会从堆内存中被释放
Python 任何低于 512 字节对象的内存释放, 并没有将内存空间返回给操作系统的虚拟内存管理器(VVM), 而是将使用过的内存块返回给内存池, 并由内存池的头部字段 freeblock 指针重新指向该内存块。


内存池初始化位于堆内存中
堆内存向高地址端增长


- malloc: 计算机内存由操作系统管理, 应用程序通过"系统调用"向操作系统申请内存, C 库函数将"系统调用"封装成内存分配器, 提供可调用的 malloc 函数
- 内存池的内存到最后还是会回收到内存池, 不会调用 C 的 free 释放掉, 以便下次使用


1. 如果要分配的内存空间大于 SMALL_REQUEST_THRESHOLD bytes(512 bytes), 将直接使用layer 1的内存分配接口进行分配
2. 否则, 使用不同的block来满足分配需求
```

##### 堆内存模型

```
arenas: 数组, 所有 arena 对象
usable_arenas: 双向链表, 所有可用 arena 
unused_arena_objects: 单向链表, 所有未使用的 arena
```



<img src=".\image\堆内存模型2.jpg" alt="堆内存模型2" style="zoom:150%;" />

![堆内存模型](.\image\堆内存模型1.webp)

```
arenas 对象:
1. 每个 Arenas 固定大小为256KB
2. 每个 Arenas 对象包装包含64个内存池
3. 对象头部用两个 struct area_object 类型的指针在堆中构成 Arenas 对象的双重链表


pool (内存池):
1. 每个 pool 固定大小为 4KB (内存分页的大小)
2. 每个 pool 包含尺寸相同的 block
3. pool 头部用两个 struct pool_heade r类型的指针构成 pool 对象的双重链表


block (块)
1. block 是最小的内存单元, 基本单位是 8bytes
2. 用 8 字节对齐的方式确定块的尺寸, 大小为 8 的整数倍
	如果想申请 27B 的内存, 会分配一个 32B 的 block
	尺寸 25~32 字节这个区间的任意 Python 对象, block 都是 32 字节
```

### block (块)

<img src=".\image\block结构体.png" alt="block结构体" style="zoom:80%;" />

##### 不同版本 CPython

```
CPython 3.6 是基于 8 字节的内存对齐
CPython 3.7 后基于 16 字节的内存对齐

block 最大 512字节

请求大小  - 实际分配大小 - 类别编号
```

<img src=".\image\block不同版本.webp" alt="block不同版本" style="zoom:80%;" />

```
内存规格有 512 种, 如果内存池分也分 512 种增加复杂性,
Python 以 8 字节为梯度，将内存块分为：8 字节、16 字节、24 字节, 共 64 种
每个小格表示 1 字节，8 个字节组成一个块( block )。灰色表示空闲内存块，蓝色表示已分配内存块，深蓝色表示应用内存请求大小
只要请求的内存大小不超过 8 字节，Python 都在这个内存池为其分配一块 8 字节内存，就算只申请 1 字节内存也是如此
内存起始地址均以计算机字为单位对齐, 此内存以字对齐可提升内存读写速度
降低了内存利用率



申请一块 28字节的内存, 实际从内存中划到32字节的一个block (从size class index为3的pool里面划出)

```



<img src=".\image\block结构.png" alt="block结构" style="zoom:70%;" />

### pool

##### 内存页和 pool

```
一个内存页大小 4k, 在 python 将其称为 pool


pool的4kB内存 = pool_header + block集合(N多大小一样的block)
```

##### pool 状态

```
full: pool 中所有 block 都已正在使用 nextoffset > maxnextoffset
used: pool 中至少有 1 个 block 已经正在使用, 且至少有 1 个 block 未被使用
empty: pool 中的所有 block 都未被使用


当 pool 状态为 fulled 时, 默认 python 内存分配器会执行两个动作:
    1. 先用内存池双重链表查找其他可用池返, 回未使用的内存块
    2. 如果当前内存池链表所有内存池都耗尽, 就要求arenas对象向第1层的PyMem函数接口分配更多的对内村给 arenas对象, 并创建新的内存池
```

##### pool_header

<img src=".\image\pool的heaer.jpg" alt="pool的heaer" style="zoom:80%;" />

```c
pool 头部是 pool_header 结构体, 48 字节

struct pool_header {
    union { block *_padding;
            uint count; } ref;          // 已使用的 block 数量
    block *freeblock;                   // 指向当前 pool 空闲块链表的第 1 块
    struct pool_header *nextpool;       // 指向下一个内存池
    struct pool_header *prevpool;       // 指向上一个内存池
    uint arenaindex;                    // 当前 pool 所属 arena 的地址
    uint szidx;                         // pool 下面的 block 的 尺寸类别编号 (8字节, 16字节等)
    uint nextoffset;                    // freeblock 的下一次偏移的位置
    uint maxnextoffset;                 // 当前 pool 最后一个 block 的偏移, 当 nextoffset 大于 maxnextoffset 时就没有可分配的 block 了
};

typedef struct pool_header *poolp;

block* pool_init(poolp pool,uint szidx){
    block* bp;// 
    uint size=0;   
    pool->ref.count=1
    pool->szidx = szidx;
    size = INDEX2SIZE(szidx);
    bp = (block *)pool + POOL_OVERHEAD;
    pool->nextoffset = POOL_OVERHEAD + (size << 1);
    pool->maxnextoffset = POOL_SIZE - size;
    pool->freeblock = bp + size;
    *(block **)(pool->freeblock) = NULL; // 构建 freeblock 链表头(尾)
    return bp;
}
```

##### pool 连续分配过程



<img src=".\image\pool1.png" alt="pool1" style="zoom:25%;" />

```
当第 1 个 block 分配出去后
freeblock 指向第 2 个 block 起始
```

<img src=".\image\pool2.png" alt="pool2" style="zoom:25%;" />

```
当第 2 个 block 分配出去后
freeblock 指向第 3 个 block 起始
```

<img src=".\image\pool3.png" alt="pool3" style="zoom:25%;" />

```
当第 1 个 block 释放时
第 1 个 block 的 next 指向 freeblock 指向的 block
freeblock 指向第 1 个 block 起始
```

![pool内存池连续分配内存动画](.\image\pool内存池连续分配内存动画.gif)

##### 内存池满载

![pool池满载状态](.\image\pool池满载状态.webp)

##### 内存池回收块

```
1. 实质上是单链表表头插入元素的算法
2. freeblock 指针所指向的内存块一直都位于链表的头部, 内存的分配的时间开销始终为O(1), 返回链表首部的内存块即可
```

例如: 内存池有 5 个内存块正在使用, 假设调用 pymalloc_free 释放内存块 Py3 再释放 Py2

```
如下图
当回收 Py3 内存块时, pymalloc_free 会将当前池 freeblock 所指向的内存指针, 保存到一个临时指针变量 lastfree
```

![pool释放块1](.\image\pool释放块1.webp)

```
1. freeblock 指向 Py3 块地址
2. pool->freeblock 将 Py3 块 8字节所有二进制都设为 0
3. Py3 指向 lastfree 指向的地址
```

![pool释放块1](.\image\pool释放块2.webp)

```
回收 Py2 内存块时, pymalloc_free 会将当前池 freeblock 所指向的内存指针, 保存到一个临时指针变量 lastfree
```

![pool释放块1](.\image\pool释放块3.webp)

```
1. freeblock 指向 Py2 块
2. pool->freeblock 将 Py2 块 8字节所有二进制都设为 0
3. Py2 指向 lastfree 指向的地址(即 Py3 块地址)
```

![pool释放块1](.\image\pool释放块4.webp)

##### 可用 pool 链表

<img src=".\image\可用pool链表1.png" alt="可用pool链表1" style="zoom:25%;" />

```
used 状态的 pool 内部还有 block 未分配, 通过 pool_header 结构体中的 nextpool 和 prevpool 指针将他们连成一个双向循环链表
```

<img src=".\image\可用pool链表2.png" alt="可用pool链表2" style="zoom:25%;" />

```
如果 pool 状态为 full, 则从链表中删除
```

<img src=".\image\可用pool链表3.png" alt="可用pool链表3" style="zoom:25%;" />

```
如果 pool 状态是由 full 变为 used 还会将它插回可用 pool 链表头部
插到链表头部是为了保证比较满的 pool 在链表前面，以便优先使用。
位于尾部的 pool 被使用的概率很低，随着时间的推移，更多的内存块被释放出来，慢慢变空。
因此，pool 链表明显头重脚轻，靠前的 pool 比较满，而靠后的 pool 比较空
当一个 pool 所有 block 都被释放，状态变为 empty, 会将它移出链表，内存页可能直接归还给操作系统，或者缓存起来以备后用
```

<img src=".\image\可用pool链表4.png" alt="可用pool链表4" style="zoom:25%;" />

##### usedpools

<img src=".\image\可用pool链表5.png" alt="可用pool链表5" style="zoom:25%;" />

```
1. 创建 pool 时, pool_header 可以设置的 szidx (类别编号)
2. 将 szidx 相同的 pool 放在同一个可用 pool 链表中, 因此有多个可用 poll 链表
3. 这些可用 poll 链表放在 usedpools 数组中. 每个元素分别对应不同的 szidx
4. 如果以 8 字节为梯度, 内存块规格可分 64 种, usedpools 有 64 个元素
	请求 5 字节, 将分配 8 字节内存块, 从 usedpools 第 0 个虚拟节点可找到 8 字节 pool 链表
	请求 56 字节, 将分配 64 字节内存块, 从 usedpools 第 7 个虚拟节点可找到 64 字节 pool 链表


虚拟节点只参与维护链表结构，并不管理内存页, 虚拟节点只使用 pool_header 结构体中的 nextpool 和 prevpool 这两个指针字段, 每个虚拟节点占用 16字节
```

### Arean 

```
arena 对象只有其内部全部 pool 均为 empty 时才会被系统回收. 如申请了大量小且短命的对象, 垃圾回收后可能出现完全空的 arena
python 进程可能长期占用一些不用的内存
```

查看内存使用情况

```python
import sys
print(sys._debugmallocstats())
```

```
Small block threshold = 512, in 32 size classes.

class   size   num pools   blocks in use  avail blocks
-----   ----   ---------   -------------  ------------
    0     16           1              31           990
    1     32           2             773           247
    2     48           4            1253           107
    3     64          25            6356            19
    4     80          21            4230            54
    5     96           3             438            72
    6    112           2             226            64
    7    128           2             126           128
    8    144           6             652            26
    9    160           1              83            19
   10    176          11            1004             8
   11    192           1              35            50
   12    208           1              38            40
   13    224           2             115            29
   14    240           1              26            42
   15    256           1              22            41
   16    272           1              16            44
   17    288           1              14            42
   18    304           3             124            35
   19    320           1              11            40
   20    336           1              10            38
   21    352           1               8            38
   22    368           1              11            33
   23    384           1               8            34
   24    400           1              24            16
   25    416           1              37             2
   26    432           1              26            11
   27    448           1              28             8
   28    464           1              25            10
   29    480           1              25             9
   30    496           1              11            21
   31    512           1              27             4

# arenas allocated total           =                    2
# arenas reclaimed                 =                    0
# arenas highwater mark            =                    2
# arenas allocated current         =                    2
2 arenas * 1048576 bytes/arena     =            2,097,152

# bytes in allocated blocks        =            1,404,720
# bytes in available blocks        =              253,904
26 unused pools * 16384 bytes      =              425,984
# bytes lost to pool headers       =                4,896
# bytes lost to quantization       =                7,648
# bytes lost to arena alignment    =                    0
Total                              =            2,097,152

arena map counts
# arena map mid nodes              =                    1
# arena map bot nodes              =                    1

# bytes lost to arena map root     =                8,192
# bytes lost to arena map mid      =                8,192
# bytes lost to arena map bot      =                2,048
Total                              =               18,432

           10 free PyDictObjects * 48 bytes each =                  480
           4 free PyFloatObjects * 24 bytes each =                   96
          3 free PyFrameObjects * 360 bytes each =                1,080
            7 free PyListObjects * 40 bytes each =                  280
   4 free 1-sized PyTupleObjects * 32 bytes each =                  128
   8 free 2-sized PyTupleObjects * 40 bytes each =                  320
   1 free 3-sized PyTupleObjects * 48 bytes each =                   48
   1 free 4-sized PyTupleObjects * 56 bytes each =                   56
   4 free 5-sized PyTupleObjects * 64 bytes each =                  256
   2 free 6-sized PyTupleObjects * 72 bytes each =                  144
   5 free 7-sized PyTupleObjects * 80 bytes each =                  400
   2 free 8-sized PyTupleObjects * 88 bytes each =                  176
   2 free 9-sized PyTupleObjects * 96 bytes each =                  192
 2 free 10-sized PyTupleObjects * 104 bytes each =                  208
 3 free 11-sized PyTupleObjects * 112 bytes each =                  336
 1 free 12-sized PyTupleObjects * 120 bytes each =                  120
 0 free 13-sized PyTupleObjects * 128 bytes each =                    0
 3 free 14-sized PyTupleObjects * 136 bytes each =                  408
 1 free 15-sized PyTupleObjects * 144 bytes each =                  144
 2 free 16-sized PyTupleObjects * 152 bytes each =                  304
 2 free 17-sized PyTupleObjects * 160 bytes each =                  320
 0 free 18-sized PyTupleObjects * 168 bytes each =                    0
 2 free 19-sized PyTupleObjects * 176 bytes each =                  352
```



##### Arean 对象

```
1. ARENA_SIZE 这个宏其实表示 arean 大小是 256KB
2. 每个 arena 对象都有 64 个 pool, 每个 pool 都是 4KB
3. arena 中的 64 个 pool 在堆内存中是连续的
4. arenas 中的每个 arena 之间内存不是连续的 (arenas 是数组, 保存的是每个 arena 的指针)
```

- Arenas 对象

```c
//定义Arena的内存尺寸
#define ARENA_SIZE              (256 << 10)     /* 256KB */

struct arena_object {
    uintptr_t address; // arena对象的地址, 由malloc分配
    block* pool_address; // 指向可用内存池的对齐指针(首个字节)
    uint nfreepools; // arena 对象 256KB 空间中可用的内存池的数量
    uint ntotalpools; // arena 中的内存池总数（无论是否可用）
    struct pool_header* freepools; // 可用池的单链接列表

    /*
     * 只要此arena_object不与已分配的arena关联, 
     * nextarena成员就用于链接单链接的“ unused_arena_objects”
     * 列表中所有未关联的arena_object。 
     * 在这种情况下, prevarena成员未使用。
     *
     * 当此arena_object与具有至少一个可用池的已分配arena相关联时, 
     * 两个成员都在双向链接的“ usable_arenas”列表中使用, 
     * 该列表按nfreepools值的升序进行维护。
     */
    struct arena_object* nextarena;
    struct arena_object* prevarena;
};
```

- 使用以下这些变量跟踪 arena 对象

```c
static struct arena_object* arenas = NULL; // 用于跟踪内存块（区域）的对象数组
static uint maxarenas = 0; // 当前 arenas 数组中的 arena 对象的数量
static struct arena_object* unused_arena_objects = NULL; // arena_objects.未使用的arena对象的单链表头部
static struct arena_object* usable_arenas = NULL; // 与具有可用池的arenas关联的arena_object的双向链表, 链表两端以NULL终止
static struct arena_object* nfp2lasta[MAX_POOLS_IN_ARENA + 1] = { NULL }; // nfp2lasta[nfp] is the last arena in usable_arenas with nfp free pools

#define INITIAL_ARENA_OBJECTS 16
```

##### arena 对象的初始化过程

```
执行python命令时, python内部默认会连续初始化7个arena对象
在 CPython 源码文件 Objects/obmalloc.c 中插入 printf 函数, 重新编译再运行, 查看输出
```

<video src=".\image\arena 初始化过程1.mp4"></video>

```
调用下面这些函数
	new_arena 是第 2 层的函数
	PyMem_RawRealloc 和 _PyMem_RawRealloc 是第 1 层
```

<img src=".\image\arena 初始化过程2.webp" alt="arena 初始化过程2" style="zoom:100%;" />

```
arena 对象向 C 底层申请的堆内存空间是连续的
arena 申请的内存是上一次的 2 倍
第一次申请 16×sizeof 的空间, 申请的堆内存是连续的, 可以容纳 16 个 arena_object 结构体, 下一次的申请量就是 32×sizeof, 容纳 32 个 arena_object 结构体
```

<img src=".\image\arena 初始化过程3.webp" alt="arena 初始化过程3" style="zoom:80%;" />



```
1. 所有的 arena 都由 arenas 数组管理
2. 新创建的 arena 对象要将 address 字段做 0 初始化, 用于标识每个新增的 arena 对象未被关联
3. 未关联的 arena 对象表示该 arena 对象还没被使用, 用 unused_arena_objects 单向链表管理这些未使用的 arena 对象


图中紫色箭头 arenas 指向所有 arena
红色箭头 unused_arena_objects 指向和 arenas 相同的位置表示都没有使用
```

<img src=".\image\arena 初始化过程4.webp" alt="arena 初始化过程4" style="zoom:80%;" />

```
1. 当使用第一个 arena 时 
2. 从 unused_arena_objects (单向链表)中移出, unused_arena_objects 指针指向了 arenas 数组的第 2 个元素的内存地址
3. usable_arenas (双向链表)指向移出的 arena 
```

<img src=".\image\arena 初始化过程5.webp" alt="arena 初始化过程5" style="zoom:80%;" />

```
nfp2lasta
    1. 是一个包含 65 个指针为元素的数组, 初始化时都为 NULL
    2. 用来记录 usable_arenas 中有空闲 pool 的 arena 对象 (最靠前的 arena)


当初始化第一个 arena 的第一个 pool 时:
1. 第一个 arena 给 64 个 pool 分配内存, 这些内存池使用时优先低地址, 再高地址
2. 此时
    usable_arenas 双链表为: NULL↔arenas[0]↔NULL
    unused_arena_objects 单链表为: arenas[1]→arenas[2]→....→arenas[14]→NULL
```

<img src=".\image\arena 初始化过程7.webp" alt="arena 初始化过程7" style="zoom:100%;" />

```
1. 同一个 arena 对象中每个内存池的 size class idx 不同 (64 个内存池). 
	例如 pool 的 size class idx 是 3, 下一个时刻在内存池的块都被回收后, size class idx 变为 11
2. nf2lasta 的下标变化和当前 usable_arenas 所指向的 arena 对象中的 nfreepools (可用内存池数量)是实时同步的
	arena 可用内存数量是 63 时, nf2lasta 索引为 62 的元素记录当前的 arena
3. 通过 nf2lasta 可以知道 arenas 中哪个 arena 在使用第几个 pool
```

<img src=".\image\arena 初始化过程8.gif" alt="arena 初始化过程8" style="zoom:100%;" />

```
当第一个 arena 满载时(里面的 64 个 pool 都是 using), CPython 将该 arena 对象从 usable_arenas (双链表)中删除, 偏移至第二个 arena 对象
```

<img src=".\image\arena 初始化过程9.webp" alt="arena 初始化过程9" style="zoom:100%;" />



<img src=".\image\arena 初始化过程10.webp" alt="arena 初始化过程9" style="zoom:100%;" />

```
这 7 个 arena 都满载时
```

<img src=".\image\arena 初始化过程11.webp" alt="arena 初始化过程9" style="zoom:100%;" />

### usedpools (没看懂)

<img src=".\image\usedpool4.png" alt="usedpool4" style="zoom:80%;" />

```

```

```c
#define SMALL_REQUEST_THRESHOLD 512
#define NB_SMALL_SIZE_CLASSES   (SMALL_REQUEST_THRESHOLD / ALIGNMENT)
```

```
28字节 的小对象, 其 size class 是 32, 不同版本的 CPython 换算的 szidx 不同
	Cpython3.6 之前 szidx 是 3
	CPython3.7 之后 szidx 是 1

CPython 根据对应的 szidx 去访问 usedpools
```

```
CPython 3.6 前
对于CPython3.6之前的是usedpool[3+3], 那么usedpools[6]->nextpool指向usedpools[4]的内存地址,并从usedpools[4]所指向的内存池(pool->freeblock)分配可用的32字节的块
```



<img src=".\image\usedpools3.6.jpg" alt="usedpools3.6" style="zoom:100%;" />

```
CPython 3.7 后
usedpools[1+1], 那么usedpools[2]->nextpool自然就指向usedpools[0], 并从usedpools[0]所指向的内存池(pool->freeblock)分配可用的32字节的块
```



<img src=".\image\usedpools3.6.jpg" alt="usedpools3.6" style="zoom:100%;" />







### 刷新机制

```
刷新: 当一个资源长时间没有使用时, 要把该资源从缓冲池中剔除
操作系统中Cache的设计机制, cache中常用换页机制, 采用的有FIFO、LRU、Clock算法。这里我们就是用LRU算法。
```



# 内存碎片

```
应用程序请求内存块尺寸不确定, 释放内存时机不确定
经典内存分配器将不同尺寸内存块混合管理, 按照先来后到的顺序分配, 将大内存切分后再次分配的做法导致内存碎片
虽然还有 1900K 的空闲内存, 但都分散在一系列不连续的碎片上, 甚至无法成功分配出 1000K 
```

<img src=".\image\内存碎片.png" alt="内存碎片" style="zoom:100%;" />



##### 经典内存分配器

<img src=".\image\内存碎片1.png" alt="内存碎片1" style="zoom:60%;" />

```
当大块内存回收后, 可以被分为更小的块, 然后分配出去
```

<img src=".\image\内存碎片2.png" alt="内存碎片2" style="zoom:60%;" />

```
而先分配的内存块未必先释放, 慢慢地空洞就出现了
```

<img src=".\image\内存碎片3.png" alt="内存碎片3" style="zoom:60%;" />

```
随着时间的推移, 碎片化会越来越严重, 最终变得支离破碎
```

<img src=".\image\内存碎片4.png" alt="内存碎片4" style="zoom:60%;" />

##### 按尺寸分类管理

```
1. 将内存划分成 小 / 中 / 大 三个不同尺寸的区域, 每个区域由若干内存页组成, 每个页都划分为统一规格的内存块
2. 各各区域独立管理, 小块内存的分配, 不会影响大块内存区域, 使其碎片化
3. 每个区域的碎片仍无法完全避免, 但这些碎片都是可以被重新分配出去的, 通过优化分配策略, 碎片还可被进一步合并
	例如小块内存, 分配新内存时优先从内存页 1 分配, 内存页 2 将慢慢变空, 最终将被整体回收
4. 在 Python 虚拟机内部, 时刻有对象创建、销毁, 这引发频繁的内存申请、释放动作。这类内存尺寸一般不大, 但分配、释放频率非常高, 因此 Python 专门设计内存池对此进行优化
```

<img src=".\image\内存碎片5.png" alt="内存碎片5" style="zoom:50%;" />

# 参考

```
好
	《Python源码剖析》
    https://www.zhihu.com/column/c_1272122576572284928


https://blog.csdn.net/zhzhl202/article/details/7547445
https://www.cnblogs.com/fasionchan/p/python-memory-pool.html
https://www.cnblogs.com/wuyanzu123/p/14698070.html
https://wklken.me/posts/2015/08/29/python-source-memory-1.html

明天看
https://wklken.me/posts/2015/08/29/python-source-memory-1.html
https://wklken.me/posts/2015/08/29/python-source-memory-2.html
https://wklken.me/posts/2015/08/28/python-base-datastructures.html

	https://www.zhihu.com/question/30560008
```

