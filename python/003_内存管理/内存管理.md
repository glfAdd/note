# 内存管理(垃圾回收)

```
机制
	引用计数
	标记清除
	内存池
时机
	达到阈值自动回收
	手动调用gc.collect()
	程序退出
```

### 引用计数

- 每个对象记录自己被引用的次数，每增加一个引用个数+1，每减少一个引用个数-1, 数为0时释放. 维护引用计数消耗资源, 循环引用时无法回收
- 对象被创建 / 引用 / 作为参数 / 作为个元素存储在容器中
- 对象的别名被显式销毁, 对象的别名被赋予新的对象, 一个对象离开它的作用域, 一个函数执行完毕时, 对象所在的容器被销毁，或从容器中删除对象

### 标记清除

- 处理容器对象循环引用
- 分为两个步骤:
  - 标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达；
  - 清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。
- 详细过程

```
在标记清除算法中，为了追踪容器对象，需要每个容器对象维护两个额外的指针，用来将容器对象组成一个双端链表，指针分别指向前后两个容器对象，方便插入和删除操作。python解释器(Cpython)维护了两个这样的双端链表，一个链表存放着需要被扫描的容器对象，另一个链表存放着临时不可达对象。

https://andrewpqc.github.io/2018/10/08/python-memory-management/


```



##### 三色标记模型 

```
垃圾收集机制一般都分为两个阶段
垃圾检测:从所有已分配的内存中区别出可以回收的内存和不可回收的内存, 基于三色标记模型建立
垃圾回收:将可回收内存归还给操作系统. 
root object:根对象,是一些全局引用和函数栈中的引用. 这些引用所用的对象是不可被删除的. 

1.在垃圾收集动作被激活之前, 对象与对象之间的引用组成一张有向图(对象和引用关系)
2.假设系统中所有对象都是不可达,白色标注
3.垃圾检测开始, 遍历root object集合中引用, 在某个时刻达到了对象A, 那么我们将A标记为灰色, 表示对象是可达的, 但是其包含的引用还没检查. 当检查了对象A所包含的所有引用之后, A将被标记为 黑色 , 黑色表示其包含的所有引用已经被检查过了. 
4.所有灰色节点都变为了黑色节点垃圾检查阶段的结束
```

##### 分代回收机制

- 提升查找循环引用的性能

```
循环引用查找和销毁过程非常繁琐，要分别处理每一个容器对象，所以python考虑一种改善性能的做法，即分代回收。
首先是一个假设--如果一个对象被检测了10次还没有被销毁，就减少对其的检测频率
基于这个假设，提出一套机制，即分代回收机制

1. 默认一个对象被创建出来后, 属于 0 代
2. 如果经历过这一代"标记-删除", 依然存活则划分到下一代
3.代数越高的对象（存活越持久的对象），进行【标记-删除】的时间间隔就越长
4. "垃圾回收"的周期顺序为 (700, 10, 5)
		0代"垃圾回收"一定次数, 会触发 0代和1代回收
		1代"垃圾回收"一定次数, 会触发0代, 1代和2代回收
```

##### 垃圾回收时机

```
1. 自动回收
开启垃圾回收机制(默认开启), 垃圾回收器中, 新增的对象个数和释放的对象个数之差到达某个阈值
gc.enable()
gc.disable()
gc.isenabled()
gc.get_threshold()
gc.set_threshold(700, 10, 5)

2. 手动回收:执行gc.collect()一次垃圾回收(开关状态无效)
import objgraph
import gc
import sys
class Person(object):
    pass
class Dog(object):
    pass
p = Person()
d = Dog()
p.pet = d
d.master = p
del p
del d
gc.collect()
print(objgraph.count("Person"))
print(objgraph.count("Dog"))

3.程序退出
```

##### 解决办法

```
尽可能避免循环引用产生, 一方使用弱引用代替
当删除一个引用, 确定以后不再使用时, 手动清空对其他容器对象的引用

测量对象的引用个数
辅助工具  objgraph
			             
```

### 内存池 memory pool

- 内存架构

```
python的对象管理主要位于Level+1~Level+3层
Level+3层：对于python内置的对象（比如int,dict等）都有独立的私有内存池，对象之间的内存池不共享，即int释放的内存，不会被分配给float使用
Level+2层：当申请的内存小于256KB时，内存分配主要由 Python 对象分配器（Python’s object allocator）实施
Level+1层：当申请的内存大于256KB时，由Python原生的内存分配器进行分配，本质上是调用C标准库中的malloc/realloc等函数
```

- python又分为大内存和小内存。大小以256字节为界限
- 当创建大量消耗小内存的对象时，频繁调用new/malloc会导致大量的内存碎片，致使效率降低。内存池的概念就是预先在内存中申请一定数量的，大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。
- 避免频繁地申请和释放内存空间, 析构时通常都是将对象占用的空间归还到内存池中
- 小于256kb时，pymalloc会在内存池中申请内存空间
- 大于256kb，则会直接执行 new/malloc 的行为来申请新的内存空间

##### 小数据池

```
整数字范围-5~256 之间的整数，解释器会在启动时创建, 数值相同的对象都是共用内存地址的.
当对象被销毁，python只会将这个对象引用回收掉，然而内存数据还是存在的, 永远不会被GC回收
```

##### Intern机制

```
只允许由数字字母及下划线组成的字符串,不能超过20个字符
当两段完全相同的字符串，会让他们共用同一段内存, 放在一个字符串储蓄池中

原理
维护一个字符串储蓄池，这个池子是一个字典结构，如果字符串已经存在于池子中就不再去创建新的字符串，直接返回之前创建好的字符串对象，如果之前还没有加入到该池子中，则先构造一个字符串对象，并把这个对象加入到池子中去，方便下一次获取
```

##### 256个ASCII码进行了对象缓冲池


