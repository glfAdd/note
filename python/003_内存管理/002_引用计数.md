# 说明

```
Python3.9 源代码

源代码在 Objects/obmalloc.c
```

# 堆栈

<img src=".\image\CPython内存堆栈.webp" alt="CPython内存堆栈" style="zoom:100%;" />

```
堆: 存储 CPython 运行时的所有对象实体
栈: 存储堆中对象实体的引用


例如
a = 'Hello Word'
'Hello Word' 是字符串对象 PyASCIIObject
CPython 会将对象实体存储到堆内存中, 
对象实体的内存地址压栈存储, 而不是将 'Hello Word' 这个字符串值压入栈, 地址赋值给变量 a


Python 任何对象都由 CPython 的 C 底层由一个叫 struct PyObject 结构体所封装. 这个结构体在 CPython 运行时存储在堆内中
```

##### 可变对象 / 不可变对象

```
可变对象: list, dict, 其内部元素可修改, 修改的是引用
不可变对象: 基本数据类型 int, float, str, byte 
```

- malloc: 计算机内存由操作系统管理, 应用程序通过"系统调用"向操作系统申请内存, C 库函数将"系统调用"封装成内存分配器, 提供可调用的 malloc 函数
- 内存池的内存到最后还是会回收到内存池, 不会调用 C 的 free 释放掉, 以便下次使用

# CPython 内存结构

<img src=".\image\CPython内存架构.webp" alt="CPython内存架构" style="zoom:100%;" />

<img src=".\image\CPython内存架构2.svg" alt="CPython内存架构2" style="zoom:50%;" />

![CPython内存架构3](.\image\CPython内存架构3.webp)

```
python 管理的是 0, 1, 2, 3 层

python 的内存分为大内存和小内存, 以256字节为界限
    小内存的对象, 使用内存池进行分配, 不调用 free 函数释放内存, 下次继续使用
    大内存的对象, 使用 malloc 函数分配内存, free 函数释放内存
```

- 第 3 层

```
对象缓冲池
python 内置基本类型（int, dict等）都有独立的私有内存池, 对象之间的内存池不共享, 即int释放的内存, 不会被分配给float使用
```

- 第 2 层

```
内存池
小内存使用内存池进行分配
当申请的内存小于256KB时, 内存分配主要由 Python 对象分配器实施
是 Python 对象分配器, Python 对象分配/释放内存(例如:PyObject_New / Del）都会调用它
```

- 第 1 层

```
大内存使用malloc进行分配
当申请的内存大于256KB时, 由 Python 原生的内存分配器进行分配, 本质上是调用 C 标准库中的 malloc/realloc 等函数
是 PyMem 内存分配函数, 它确保 CPython 运行时, 堆中有足够可用的堆内存，如果没有，它会向下一层请求更多的内存.
```

- 第 0 层

```
C 库中的 malloc, free 等函数直接和操作系统的虚拟内存管理器交互, 分配和释放内存
并且接受来自上一层 PyMem 内存分配函数的内存空间请求, 以及将系统分配的内存空间返回给上一层 PyMem
```

- 第 -1 层

```
虚拟内存管理原理
基于页表的虚拟内存管理器，以页 ( page )为单位管理内存，CPU 内存管理单元( MMU )在这个过程中发挥重要作用
```

- 第 -2 层

```
操作系统进行操作
底层存储设备, 直接管理物理内存以及磁盘等二级存储设备
```

## 内存管理架构

![L1内存管理](.\image\L1内存管理.webp)

```
PyMem_* 位于 CPython 内存模型第1层
_PyObject_* 函数族衔接第1层和第2层的
```

```c
typedef struct {
    // 用户上下文作为第一个参数
    void *ctx;
    // 分配一块内存
    void* (*malloc) (void *ctx, size_t size);
    // 分配以零初始化的内存块
    void* (*calloc) (void *ctx, size_t nelem, size_t elsize);
    // 分配或调整内存块大小
    void* (*realloc) (void *ctx, void *ptr, size_t new_size);
    // 释放内存块
    void (*free) (void *ctx, void *ptr);
} PyMemAllocatorEx;


static PyMemAllocatorEx _PyMem_Raw = {
    NULL,
    _PyMem_RawMalloc,
    _PyMem_RawCalloc,
    _PyMem_RawRealloc,
    _PyMem_RawFree
};
```

## 大对象和小对象

![L1和L2交互](.\image\L1和L2交互.webp)

```
Python3 中默认的小内存与大内存的分界点是512字节


大对象:
1. 大于512字节的 Python 对象
2. Arenas 对象 256KB 就是 CPython 的大对象, 此时给 Arenas 大对象的内存分配, CPython 会调用第 0 层 C 库的 malloc 分配器为其分配内存(PyMem_RawMalloc 或 PyMem_RawRealloc)
因此 C 底层的 malloc 分配器是仅供给 arenas 对象使用的


小对象:
1. 小于等于 512 字节的 Python 对象
2. PyObject_Malloc 会在内存池中申请内存


申请 28字节的内存时, Python 内部会在内存池寻找一块能满足需求的 pool, 并从中取出一个 32 字节的 block, 而不会去需找arena
```



## 内存池

##### 作用

```
1. 避免频繁地申请、释放内存空间(malloc 与 free)导致性能降低;
2. 避免频繁分配与释放小块的内存会产生内存碎片导致降低内存利用效率	

Python 对象都有一个引用计数器，当引用计数为0时，被引用的 Python 对象就会从堆内存中被释放
Python 任何低于 512 字节对象的内存释放，并没有将内存空间返回给操作系统的虚拟内存管理器(VVM)，而是将使用过的内存块返回给内存池，并由内存池的头部字段 freeblock 指针重新指向该内存块。


内存池初始化位于堆内存中
堆内存向高地址端增长


```

##### 堆内存模型

![堆内存模型](.\image\堆内存模型.webp)

```
arenas 对象:
1. 每个 Arenas 固定大小为256KB
2. 每个 Arenas 对象包装包含64个内存池
3. 对象头部用两个 struct area_object 类型的指针在堆中构成 Arenas 对象的双重链表


pool (内存池):
1. 每个 pool 固定大小为 4KB (内存分页的大小)
2. 每个 pool 包含尺寸相同的 block
3. pool 头部用两个 struct pool_heade r类型的指针构成 pool 对象的双重链表


block (块)
1. block 是最小的内存单元, 基本单位是 8bytes
2. 用 8 字节对齐的方式确定块的尺寸, 大小为 8 的整数倍
	如果想申请 27B 的内存, 会分配一个 32B 的 block
	尺寸 25~32 字节这个区间的任意 Python 对象, block 都是 32 字节
```

### block (块)

<img src=".\image\block不同版本.webp" alt="block不同版本" style="zoom:80%;" />

<font color='red'>CPython 3.6 是基于 8 字节的内存对齐</font>
<font color='red'>CPython 3.7 后基于 16 字节对齐</font>

```
 * Request in bytes     Size of allocated block      Size class idx
 * ----------------------------------------------------------------
 *        1-8                     8                       0
 *        9-16                   16                       1
 *       17-24                   24                       2
 *       25-32                   32                       3
 *       33-40                   40                       4
 *       41-48                   48                       5
 *       49-56                   56                       6
 *       57-64                   64                       7
 *       65-72                   72                       8
 *        ...                   ...                     ...
 *      497-504                 504                      62
 *      505-512                 512                      63
```

### pool

##### pool 状态

```
full (满载): pool 中所有 block 都已正在使用 nextoffset > maxnextoffset
used: pool 中至少有 1 个 block 已经正在使用, 且至少有 1 个 block 未被使用
empty: pool 中的所有 block 都未被使用


当 pool 状态为 fulled 时, 默认 python 内存分配器会执行两个动作:
    1. 先用内存池双重链表查找其他可用池返, 回未使用的内存块
    2. 如果当前内存池链表所有内存池都耗尽, 就要求arenas对象向第1层的PyMem函数接口分配更多的对内村给 arenas对象，并创建新的内存池
```

##### pool (池)

<img src=".\image\pool的heaer.jpg" alt="pool的heaer" style="zoom:80%;" />

```c
struct pool_header {
    union { block *_padding;
            uint count; } ref;          // 已分配内存块的数量
    block *freeblock;                   // 标识下一次分配block的起始位置
    struct pool_header *nextpool;       // 指向下一个内存池
    struct pool_header *prevpool;       // 指向上一个内存池
    uint arenaindex;                    // 当前 pool 所属的 arena 的索引
    uint szidx;                         // block size class index (分配出去的 block 的单位大小, 8字节, 16字节等等)
    uint nextoffset;                    // freeblock 的下一次偏移的位置
    uint maxnextoffset;                 // 当前 pool 最后一个 block 的偏移, 当 nextoffset 大于 maxnextoffset 时就没有可分配的 block 了
};

typedef struct pool_header *poolp;


block* pool_init(poolp pool,uint szidx){
    block* bp;// 
    uint size=0;
    
    pool->ref.count=1
    pool->szidx = szidx;
    size = INDEX2SIZE(szidx);
    bp = (block *)pool + POOL_OVERHEAD;
    pool->nextoffset = POOL_OVERHEAD + (size << 1);
    pool->maxnextoffset = POOL_SIZE - size;
    pool->freeblock = bp + size;
    //构建 freeblock 链表头(尾)
    *(block **)(pool->freeblock) = NULL;

    return bp;
}
```

##### pool 连续分配内存

![pool内存池连续分配内存动画](.\image\pool内存池连续分配内存动画.gif)



##### 内存池满载

![pool池满载状态](.\image\pool池满载状态.webp)

##### 内存池回收块

```
1. 实质上是单链表表头插入元素的算法
2. freeblock 指针所指向的内存块一直都位于链表的头部, 内存的分配的时间开销始终为O(1), 返回链表首部的内存块即可
```

例如: 内存池有 5 个内存块正在使用，假设调用 pymalloc_free 释放内存块 Py3 再释放 Py2

```
如下图
当回收 Py3 内存块时, pymalloc_free 会将当前池 freeblock 所指向的内存指针，保存到一个临时指针变量 lastfree
```

![pool释放块1](.\image\pool释放块1.webp)

```
1. freeblock 指向 Py3 块地址
2. pool->freeblock 将 Py3 块 8字节所有二进制都设为 0
3. Py3 指向 lastfree 指向的地址
```

![pool释放块1](.\image\pool释放块2.webp)

```
回收 Py2 内存块时, pymalloc_free 会将当前池 freeblock 所指向的内存指针，保存到一个临时指针变量 lastfree
```

![pool释放块1](.\image\pool释放块3.webp)

```
1. freeblock 指向 Py2 块
2. pool->freeblock 将 Py2 块 8字节所有二进制都设为 0
3. Py2 指向 lastfree 指向的地址(即 Py3 块地址)
```

![pool释放块1](.\image\pool释放块4.webp)



### Arean 

##### Arean 对象

```
1. ARENA_SIZE 这个宏其实表示 arean 大小是 256KB
2. 每个 arena 对象都有 64 个 pool, 每个 pool 都是 4KB
3. arena 中的 64 个 pool 在堆内存中是连续的
4. arenas 中的每个 arena 之间内存不是连续的 (arenas 是数组, 保存的是每个 arena 的指针)
```

- Arenas 对象

```c
//定义Arena的内存尺寸
#define ARENA_SIZE              (256 << 10)     /* 256KB */

struct arena_object {
    uintptr_t address; // arena对象的地址，由malloc分配
    block* pool_address; // 指向可用内存池的对齐指针(首个字节)
    uint nfreepools; // arena 对象 256KB 空间中可用的内存池的数量
    uint ntotalpools; // arena 中的内存池总数（无论是否可用）
    struct pool_header* freepools; // 可用池的单链接列表

    /*
     * 只要此arena_object不与已分配的arena关联，
     * nextarena成员就用于链接单链接的“ unused_arena_objects”
     * 列表中所有未关联的arena_object。 
     * 在这种情况下，prevarena成员未使用。
     *
     * 当此arena_object与具有至少一个可用池的已分配arena相关联时，
     * 两个成员都在双向链接的“ usable_arenas”列表中使用，
     * 该列表按nfreepools值的升序进行维护。
     */
    struct arena_object* nextarena;
    struct arena_object* prevarena;
};
```

- 使用以下这些变量跟踪 arena 对象

```c
static struct arena_object* arenas = NULL; // 用于跟踪内存块（区域）的对象数组
static uint maxarenas = 0; // 当前 arenas 数组中的 arena 对象的数量
static struct arena_object* unused_arena_objects = NULL; // arena_objects.未使用的arena对象的单链表头部
static struct arena_object* usable_arenas = NULL; // 与具有可用池的arenas关联的arena_object的双向链表，链表两端以NULL终止
static struct arena_object* nfp2lasta[MAX_POOLS_IN_ARENA + 1] = { NULL }; // nfp2lasta[nfp] is the last arena in usable_arenas with nfp free pools

#define INITIAL_ARENA_OBJECTS 16
```

##### arena 对象的初始化过程

```
执行python命令时，python内部默认会连续初始化7个arena对象
在 CPython 源码文件 Objects/obmalloc.c 中插入 printf 函数, 重新编译再运行, 查看输出
```

<video src=".\image\arena 初始化过程1.mp4"></video>

```
调用下面这些函数
	new_arena 是第 2 层的函数
	PyMem_RawRealloc 和 _PyMem_RawRealloc 是第 1 层
```

<img src=".\image\arena 初始化过程2.webp" alt="arena 初始化过程2" style="zoom:100%;" />

```
arena 对象向 C 底层申请的堆内存空间是连续的
arena 申请的内存是上一次的 2 倍
第一次申请 16×sizeof 的空间, 申请的堆内存是连续的, 可以容纳 16 个 arena_object 结构体, 下一次的申请量就是 32×sizeof, 容纳 32 个 arena_object 结构体
```

<img src=".\image\arena 初始化过程3.webp" alt="arena 初始化过程3" style="zoom:80%;" />



```
1. 所有的 arena 都由 arenas 数组管理
2. 新创建的 arena 对象要将 address 字段做 0 初始化, 用于标识每个新增的 arena 对象未被关联
3. 未关联的 arena 对象表示该 arena 对象还没被使用, 用 unused_arena_objects 单向链表管理这些未使用的 arena 对象


图中紫色箭头 arenas 指向所有 arena
红色箭头 unused_arena_objects 指向和 arenas 相同的位置表示都没有使用
```

<img src=".\image\arena 初始化过程4.webp" alt="arena 初始化过程4" style="zoom:80%;" />

```
1. 当使用第一个 arena 时 
2. 从 unused_arena_objects (单向链表)中移出, unused_arena_objects 指针指向了 arenas 数组的第 2 个元素的内存地址
3. usable_arenas (双向链表)指向移出的 arena 
```

<img src=".\image\arena 初始化过程5.webp" alt="arena 初始化过程5" style="zoom:80%;" />

```
nfp2lasta
    1. 是一个包含 65 个指针为元素的数组, 初始化时都为 NULL
    2. 用来记录 usable_arenas 中有空闲 pool 的 arena 对象 (最靠前的 arena)


当初始化第一个 arena 的第一个 pool 时:
1. 第一个 arena 给 64 个 pool 分配内存, 这些内存池使用时优先低地址, 再高地址
2. 此时
    usable_arenas 双链表为: NULL↔arenas[0]↔NULL
    unused_arena_objects 单链表为: arenas[1]→arenas[2]→....→arenas[14]→NULL
```

<img src=".\image\arena 初始化过程7.webp" alt="arena 初始化过程7" style="zoom:100%;" />

```
1. 同一个 arena 对象中每个内存池的 size class idx 不同 (64 个内存池). 
	例如 pool 的 size class idx 是 3, 下一个时刻在内存池的块都被回收后，size class idx 变为 11
2. nf2lasta 的下标变化和当前 usable_arenas 所指向的 arena 对象中的 nfreepools (可用内存池数量)是实时同步的
	arena 可用内存数量是 63 时, nf2lasta 索引为 62 的元素记录当前的 arena
3. 通过 nf2lasta 可以知道 arenas 中哪个 arena 在使用第几个 pool
```

<img src=".\image\arena 初始化过程8.gif" alt="arena 初始化过程8" style="zoom:100%;" />

```
当第一个 arena 满载时(里面的 64 个 pool 都是 using), CPython 将该 arena 对象从 usable_arenas (双链表)中删除, 偏移至第二个 arena 对象
```

<img src=".\image\arena 初始化过程9.webp" alt="arena 初始化过程9" style="zoom:100%;" />



<img src=".\image\arena 初始化过程10.webp" alt="arena 初始化过程9" style="zoom:100%;" />

```
这 7 个 arena 都满载时
```

<img src=".\image\arena 初始化过程11.webp" alt="arena 初始化过程9" style="zoom:100%;" />

### usedpools (没看懂)

```
数组

维护者所有处于used状态的pool。

当申请内存size class为N时，Python会通过usedpools查找到与N对应的size idx可用的内存池，从中分配一个类型尺寸为N的块，

我们看看


其中的NB_SMALL_SIZE_CLASSES标识当前的CPython实现有多少个size class，
对于CPython3.6之前表示有64种size class，
CPython3.7之后有32种size class.
```

```c
#define SMALL_REQUEST_THRESHOLD 512
#define NB_SMALL_SIZE_CLASSES   (SMALL_REQUEST_THRESHOLD / ALIGNMENT)
```

```
28字节 的小对象, 其 size class 是 32, 不同版本的 CPython 换算的 szidx 不同
	Cpython3.6 之前 szidx 是 3
	CPython3.7 之后 szidx 是 1

CPython 根据对应的 szidx 去访问 usedpools
```

```
CPython 3.6 前
对于CPython3.6之前的是usedpool[3+3]，那么usedpools[6]->nextpool指向usedpools[4]的内存地址,并从usedpools[4]所指向的内存池(pool->freeblock)分配可用的32字节的块
```



<img src=".\image\usedpools3.6.jpg" alt="usedpools3.6" style="zoom:100%;" />

```
CPython 3.7 后
usedpools[1+1]，那么usedpools[2]->nextpool自然就指向usedpools[0]，并从usedpools[0]所指向的内存池(pool->freeblock)分配可用的32字节的块
```



<img src=".\image\usedpools3.6.jpg" alt="usedpools3.6" style="zoom:100%;" />







### 小对象内存管理



### 对象缓冲池

# 内存碎片

# 参考

```
好
    https://www.zhihu.com/column/c_1272122576572284928


https://blog.csdn.net/zhzhl202/article/details/7547445
https://www.zhihu.com/question/30560008
https://www.cnblogs.com/fasionchan/p/python-memory-pool.html
```

