# 旧

```python
小整数对象池
[-5, 257) 这些整数对象是提前建立好的，不会被垃圾回收，所有位于这个范围内的整数使用的都是同一个对象，常驻内存

大整数对象池
小整数对象池范围之外的整数，每一个大整数，均创建一个新的对象。引用计数为0，销毁
 
intern机制
字符串没有特殊字符（空格等），且内容相同，共用一份
字符串有特殊字符（空格等），且内容相同，不共用一份
字符串内容不相同，不共用一份
In [1]: a = "helloword"
In [2]: b = "helloword"
In [3]: id(a)
Out[3]: 140171827490224
In [4]: id(b)
Out[4]: 140171827490224
In [6]: c = "hello word"
In [7]: d = "hello word"
In [8]: id(c)
Out[8]: 140171820487424
In [9]: id(d)
Out[9]: 140171820487040
 
单个字符共用对象，常驻内存
单个单词，不可修改，默认开启intern机制，共用对象，引用计数为0，则销毁 
数值类型和字符串类型在 Python 中都是不可变的，这意味着你无法修改这个对象的值，每次对变量的修改，实际上是创建一个新的对象
```

引用计数机制

```python
python采用的是引用计数机制为主，隔代回收（分代回收）为辅。
python引用计数为0时立刻释放
只靠引用计数不能解决循环引用问题，要用到隔代回收（分代回收）

python垃圾清理的本质时调用__del__方法释放对象，如果重写了这个方法但没有调用父类本来的方法，虽然触发了清理，但是不起作用。

typedef struct_object {
    int ob_refcnt;
    struct_typeobject *ob_type;
} PyObject;
python里每一个东西都是对象，它们的核心就是一个结构体PyObject，是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少。当引用计数为0时，该对象生命就结束了。
优点：简单。实时性，一旦没有引用，内存就直接释放了
缺点：维护引用计数消耗资源。循环引用
list1 = []
list2 = []
list1.append(list2)
list2.append(list1)
 
导致引用计数+1的情况:
对象被创建，例如a=23
对象被引用，例如b=a
对象被作为参数，传入到一个函数中，例如func(a)
对象作为一个元素，存储在容器中，例如list1=[a,a]

导致引用计数-1的情况:
对象的别名被显式销毁，例如del a
对象的别名被赋予新的对象，例如a=24
一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）
对象所在的容器被销毁，或从容器中删除对象

查看一个对象的引用计数:
import sys
a = "hello world"
sys.getrefcount(a)
可以查看a对象的引用计数，但是比正常计数大1，因为调用函数的时候传入a，这会让a的引用计数+1
--------------------------------------------
循环引用例子
import gc 

class ClassA():
    def __init__(self):
        print("----")

def test():
    while True:
        a1 = ClassA()
        a2 = ClassA()
        a1.b = a2
        a2.b = a1
        del a1
        del a2
        gc.cllect() # disable()了可以cllect()手动执行垃圾清理

gc.disable() # 关闭gc功能
# gc.enable() # 打开gc功能
test()
# 不同版本python的gc模块有的默认开启，有的关闭
```

隔代回收（分代回收）

```python
创建有3个链表：0代 1代 2代
每新创建的对象都会加到0代链表上

0代链表的所用对象先看有没有循环引用，是循环引用引用计数-1，不是所有对象-1，引用计数变为0的对象释放掉不是0的依然放在0链表上。没有循环引用且没有释放的对象移动到1代链表。
1代链表清理多少次后剩下的移动到2代链表
```

gc模块常用功能

```python
gc.get_count() 获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表
(345, 1, 4)
345		0代剩余没释放对象个数
1		1代清理的次数
4		2代清理的次数

gc.get_threshold() 获取的gc模块中自动执行垃圾回收的频率
(700, 10, 10)
700		0代剩余没有释放的对象大于700时清理0代
10		每清理10次0代就清理1次1代，同时清理0代
10		每清理10次1代就清理1次2代，同时清理0和1代

gc.set_threshold(threshold0[, threshold1[, threshold2]) 设置自动执行垃圾回收的频率
gc.set_threshold(500, 2, 2)   
--------------------------------------------
#coding=utf-8
import gc

class ClassA():
    def __init__(self):
        print('object born,id:%s'%str(hex(id(self))))
    # def __del__(self):
    #     print('object del,id:%s'%str(hex(id(self))))

def f3():
    print("-----0------")
    # print(gc.collect())
    c1 = ClassA()
    c2 = ClassA()
    c1.t = c2
    c2.t = c1
    print("-----1------")
    del c1
    del c2
    print("-----2------")
    print(gc.garbage)	# 返回上次被清理的对象
    print("-----3------")
    print(gc.collect()) # 显式执行垃圾回收。手动执行垃圾清理
    print("-----4------")
    print(gc.garbage)
    print("-----5------")

if __name__ == '__main__':
    gc.set_debug(gc.DEBUG_LEAK) #设置gc模块的日志
    f3()
                            
打印结果
-----0------
object born,id:0x724b20
object born,id:0x724b48
-----1------
-----2------
[]
-----3------
gc: collectable <ClassA instance at 0x724b20>
gc: collectable <ClassA instance at 0x724b48>
gc: collectable <dict 0x723300>
gc: collectable <dict 0x71bf60>
4
-----4------
[<__main__.ClassA instance at 0x724b20>, <__main__.ClassA instance at 0x724b48>, {'t': <__main__.ClassA instance at 0x724b48>}, {'t': <__main__.ClassA instance at 0x724b20>}]
-----5------                        
```

# 新

##### 概述

```
机制
	引用计数
	标记清除
	内存池

时机
	达到阈值自动回收
	手动调用gc.collect()
	程序退出
```



### 标记清除

- 处理容器对象循环引用
- 分为两个步骤:
  - 标记阶段, 遍历所有的对象, 如果是可达的（reachable）, 也就是还有对象引用它, 那么就标记该对象为可达；
  - 清除阶段, 再次遍历对象, 如果发现某个对象没有标记为可达, 则就将其回收。
- 详细过程

```
在标记清除算法中, 为了追踪容器对象, 需要每个容器对象维护两个额外的指针, 用来将容器对象组成一个双端链表, 指针分别指向前后两个容器对象, 方便插入和删除操作。python解释器(Cpython)维护了两个这样的双端链表, 一个链表存放着需要被扫描的容器对象, 另一个链表存放着临时不可达对象。

https://andrewpqc.github.io/2018/10/08/python-memory-management/


```



##### 三色标记模型 

```
垃圾收集机制一般都分为两个阶段
垃圾检测:从所有已分配的内存中区别出可以回收的内存和不可回收的内存, 基于三色标记模型建立
垃圾回收:将可回收内存归还给操作系统. 
root object:根对象,是一些全局引用和函数栈中的引用. 这些引用所用的对象是不可被删除的. 

1.在垃圾收集动作被激活之前, 对象与对象之间的引用组成一张有向图(对象和引用关系)
2.假设系统中所有对象都是不可达,白色标注
3.垃圾检测开始, 遍历root object集合中引用, 在某个时刻达到了对象A, 那么我们将A标记为灰色, 表示对象是可达的, 但是其包含的引用还没检查. 当检查了对象A所包含的所有引用之后, A将被标记为 黑色 , 黑色表示其包含的所有引用已经被检查过了. 
4.所有灰色节点都变为了黑色节点垃圾检查阶段的结束
```

##### 分代回收机制

- 提升查找循环引用的性能

```
循环引用查找和销毁过程非常繁琐, 要分别处理每一个容器对象, 所以python考虑一种改善性能的做法, 即分代回收。
首先是一个假设--如果一个对象被检测了10次还没有被销毁, 就减少对其的检测频率
基于这个假设, 提出一套机制, 即分代回收机制

1. 默认一个对象被创建出来后, 属于 0 代
2. 如果经历过这一代"标记-删除", 依然存活则划分到下一代
3.代数越高的对象（存活越持久的对象）, 进行【标记-删除】的时间间隔就越长
4. "垃圾回收"的周期顺序为 (700, 10, 5)
		0代"垃圾回收"一定次数, 会触发 0代和1代回收
		1代"垃圾回收"一定次数, 会触发0代, 1代和2代回收
```

##### 垃圾回收时机

```
1. 自动回收
开启垃圾回收机制(默认开启), 垃圾回收器中, 新增的对象个数和释放的对象个数之差到达某个阈值
gc.enable()
gc.disable()
gc.isenabled()
gc.get_threshold()
gc.set_threshold(700, 10, 5)

2. 手动回收:执行gc.collect()一次垃圾回收(开关状态无效)
import objgraph
import gc
import sys
class Person(object):
    pass
class Dog(object):
    pass
p = Person()
d = Dog()
p.pet = d
d.master = p
del p
del d
gc.collect()
print(objgraph.count("Person"))
print(objgraph.count("Dog"))

3.程序退出
```

##### 解决办法

```
尽可能避免循环引用产生, 一方使用弱引用代替
当删除一个引用, 确定以后不再使用时, 手动清空对其他容器对象的引用

测量对象的引用个数
辅助工具  objgraph
			             
```

# 内存泄漏

##### 内存泄露的情况

- 1.对象被另一个生命周期特别长的对象所引用，比如网络服务器，可能存在一个全局的单例ConnectionManager，管理所有的连接Connection，如果当Connection理论上不再被使用的时候，没有从ConnectionManager中删除，那么就造成了内存泄露。
- 2.循环引用中的对象定义了_ _ del _ _函数。如果定义了____del__函数，那么在循环引用中Python解释器无法判断析构对象的顺序，因此就不做处理。
- 没有__ __del____()函数的对象间的循环引用是可以被垃圾回收器回收掉的

##### objgraph使用

- 泄露的对象红框表示

```python
import objgraph

class OBJ(object):
    pass

def test1():
    a = OBJ()
    a.attr = a

if __name__ == '__main__':
    objgraph.show_growth()
    test1()
    a = objgraph.by_type('OBJ')
    # 回该类型对象的数目
    print objgraph.count('OBJ')
    # 打印该类型的对象列表
    objgraph.by_type('OBJ')
    # 打印实例最多的前N（limits）个对象
    objgraph.show_most_common_types(limit=5)
    # 打印自上次调用以来增加得最多的对象，这个函数非常有利于发现潜在的内存泄露
    objgraph.show_growth()
    # 生产一张有关objs的引用图
    objgraph.show_backrefs(objgraph.by_type('OBJ')[0], max_depth=10, filename="image1.png")
    # find_backref_chain： 找到一条指向obj对象的最短路径
    # show_chain： 将find_backref_chain 找到的路径画出来，只是排除了所有不在路径中的节点
    objgraph.show_chain(objgraph.find_backref_chain(objgraph.by_type('OBJ')[0], objgraph.is_proper_module), filename='image2.png')
```

##### set_debug

```python
# 在收集期间打印统计。调整收集频率时，此信息可能很有用。
gc.DEBUG_STATS
# 打印找到可收集对象的信息
gc.DEBUG_COLLECTABLE
# 打印找到的不可收集对象的信息（不可达但不能被收集器释放的对象）。这些对象将被添加到garbage列表中。
gc.DEBUG_UNCOLLECTABLE
# 当DEBUG_COLLECTABLE或者DEBUG_UNCOLLECTABLE被设置时，打印关于找到的实例对象的信息。
gc.DEBUG_INSTANCES
# 当DEBUG_COLLECTABLE或者DEBUG_UNCOLLECTABLE被设置时，打印关于找到的实例对象以外的对象的信息。
gc.DEBUG_OBJECTS
# 设置时，找到的所有不可访问的对象将被追加到垃圾中，而不是被释放。这对调试泄漏程序很有用。
gc.DEBUG_SAVEALL
# 收集器需要打印有关泄漏程序（等于DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | DEBUG_INSTANCES | DEBUG_OBJECTS | DEBUG_SAVEALL）的信息的调试标志。
gc.DEBUG_LEAK
```

##### gc模块

```python
gc.disable()  					# 暂停自动垃圾回收.
gc.collect()  					# 执行一次完整的垃圾回收, 返回垃圾回收所找到无法到达的对象的数量.
gc.set_threshold(700, 10, 5)  	# 设置Python垃圾回收的阈值.
gc.get_threshold()
gc.set_debug()  				# 设置垃圾回收的调试标记. 调试信息会被写入std.err.
gc.garbage						# 是一个list对象，列表项是垃圾收集器发现的不可达（即垃圾对象）、但又不能释放(不可回收)的对象，通常gc.garbage中的对象是引用对象还中的对象。因Python不知用什么顺序来调用对象的__del__函数，导致对象始终存活在gc.garbage中，造成内存泄露
```

##### 定位循环引用

- 除非定义了__del__方法，那么循环引用也不是什么万恶不赦的东西。垃圾回收器可以处理循环引用，python标准库还是第三方库都可能存在循环引用。如果存在循环引用Python的gc就必须开启，否则就会内存泄露。但是在某些情况下，我们还是不希望有gc，比如对内存和性能比较敏感的应用场景，提到instagram通过禁用gc，性能提升了10%；另外，在一些应用场景，垃圾回收带来的卡顿也是不能接受的，比如RPG游戏。执行一次垃圾回收是很耗费时间的，因为需要遍历所有被collector管理的对象（即使很多对象不属于垃圾）。因此，要想禁用GC，就得先彻底干掉循环引用。

```python
# 方式1
import objgraph, gc

class OBJ(object):
    pass

def show_cycle_reference():
    a, b = OBJ(), OBJ()
    a.attr_b = b
    b.attr_a = a

if __name__ == '__main__':
    # 一定要先禁用gc防止误差
    gc.disable()
    for _ in xrange(50):
        show_cycle_reference()
    # 里面会调用gc.collect()
    # objgraph.show_growth()
    objgraph.show_most_common_types(50)
# 内存中现在有100个OBJ对象
----------------------------------------------------------
# 方式2
import gc, time, objgraph

class OBJ(object):
    pass

def show_cycle_reference():
    a, b = OBJ(), OBJ()
    a.attr_b = b
    b.attr_a = a

if __name__ == '__main__':
    gc.disable()
    gc.set_debug(gc.DEBUG_SAVEALL | gc.DEBUG_OBJECTS)
    for _ in xrange(1):
        show_cycle_reference()
    print gc.garbage  # []
    gc.collect()
    print gc.garbage
    time.sleep(2)

    # 设置了DEBUG_SAVEALL执行collect以后放入了garbage里面
    objgraph.show_backrefs(objgraph.by_type('OBJ')[0], max_depth=20, filename="image4.png")
```

##### 消灭循环引用

```python
# 弱引用
# 创建一个对object的弱引用，返回值为weakref对象，callback: 当object被删除的时候，会调用callback函数
weakref.ref(object, callback = None)

# 弱引用代理
weakref.proxy(object, callback = None)



```

# 新2

##### 循环引用

```
循环引用导致内存泄漏
只有容器对象之间才会循环引用
```

```c
// 每个容器对象头部增加这个结构体, 用于 GC
// 通过 _gc_head 构成双向循环链表

typedef union _gc_head {
    struct {
        union _gc_head *gc_next;
        union _gc_head *gc_prev;
        Py_ssize_t gc_refs;
    } gc;
    long double dummy;  /* force worst-case alignment */
} PyGC_Head;
```





##### 标记清除

```

```

##### 分代回收

```

```

