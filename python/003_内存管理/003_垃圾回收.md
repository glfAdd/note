##### 概述

```
机制
	引用计数
	标记清除
	内存池

时机
	达到阈值自动回收
	手动调用gc.collect()
	程序退出
```



##### 三色标记模型 

```
垃圾收集机制一般都分为两个阶段
垃圾检测:从所有已分配的内存中区别出可以回收的内存和不可回收的内存, 基于三色标记模型建立
垃圾回收:将可回收内存归还给操作系统. 
root object:根对象,是一些全局引用和函数栈中的引用. 这些引用所用的对象是不可被删除的. 

1.在垃圾收集动作被激活之前, 对象与对象之间的引用组成一张有向图(对象和引用关系)
2.假设系统中所有对象都是不可达,白色标注
3.垃圾检测开始, 遍历root object集合中引用, 在某个时刻达到了对象A, 那么我们将A标记为灰色, 表示对象是可达的, 但是其包含的引用还没检查. 当检查了对象A所包含的所有引用之后, A将被标记为 黑色 , 黑色表示其包含的所有引用已经被检查过了. 
4.所有灰色节点都变为了黑色节点垃圾检查阶段的结束
```





# 内存泄漏

##### 内存泄露的情况

- 1.对象被另一个生命周期特别长的对象所引用，比如网络服务器，可能存在一个全局的单例ConnectionManager，管理所有的连接Connection，如果当Connection理论上不再被使用的时候，没有从ConnectionManager中删除，那么就造成了内存泄露。
- 2.循环引用中的对象定义了_ _ del _ _函数。如果定义了____del__函数，那么在循环引用中Python解释器无法判断析构对象的顺序，因此就不做处理。
- 没有__ __del____()函数的对象间的循环引用是可以被垃圾回收器回收掉的

##### objgraph使用

- 泄露的对象红框表示

```python
import objgraph

class OBJ(object):
    pass

def test1():
    a = OBJ()
    a.attr = a

if __name__ == '__main__':
    objgraph.show_growth()
    test1()
    a = objgraph.by_type('OBJ')
    # 回该类型对象的数目
    print objgraph.count('OBJ')
    # 打印该类型的对象列表
    objgraph.by_type('OBJ')
    # 打印实例最多的前N（limits）个对象
    objgraph.show_most_common_types(limit=5)
    # 打印自上次调用以来增加得最多的对象，这个函数非常有利于发现潜在的内存泄露
    objgraph.show_growth()
    # 生产一张有关objs的引用图
    objgraph.show_backrefs(objgraph.by_type('OBJ')[0], max_depth=10, filename="image1.png")
    # find_backref_chain： 找到一条指向obj对象的最短路径
    # show_chain： 将find_backref_chain 找到的路径画出来，只是排除了所有不在路径中的节点
    objgraph.show_chain(objgraph.find_backref_chain(objgraph.by_type('OBJ')[0], objgraph.is_proper_module), filename='image2.png')
```

##### set_debug

```python
# 在收集期间打印统计。调整收集频率时，此信息可能很有用。
gc.DEBUG_STATS
# 打印找到可收集对象的信息
gc.DEBUG_COLLECTABLE
# 打印找到的不可收集对象的信息（不可达但不能被收集器释放的对象）。这些对象将被添加到garbage列表中。
gc.DEBUG_UNCOLLECTABLE
# 当DEBUG_COLLECTABLE或者DEBUG_UNCOLLECTABLE被设置时，打印关于找到的实例对象的信息。
gc.DEBUG_INSTANCES
# 当DEBUG_COLLECTABLE或者DEBUG_UNCOLLECTABLE被设置时，打印关于找到的实例对象以外的对象的信息。
gc.DEBUG_OBJECTS
# 设置时，找到的所有不可访问的对象将被追加到垃圾中，而不是被释放。这对调试泄漏程序很有用。
gc.DEBUG_SAVEALL
# 收集器需要打印有关泄漏程序（等于DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | DEBUG_INSTANCES | DEBUG_OBJECTS | DEBUG_SAVEALL）的信息的调试标志。
gc.DEBUG_LEAK
```

##### 定位循环引用

- 除非定义了__del__方法，那么循环引用也不是什么万恶不赦的东西。垃圾回收器可以处理循环引用，python标准库还是第三方库都可能存在循环引用。如果存在循环引用Python的gc就必须开启，否则就会内存泄露。但是在某些情况下，我们还是不希望有gc，比如对内存和性能比较敏感的应用场景，提到instagram通过禁用gc，性能提升了10%；另外，在一些应用场景，垃圾回收带来的卡顿也是不能接受的，比如RPG游戏。执行一次垃圾回收是很耗费时间的，因为需要遍历所有被collector管理的对象（即使很多对象不属于垃圾）。因此，要想禁用GC，就得先彻底干掉循环引用。

```python
# 方式1
import objgraph, gc

class OBJ(object):
    pass

def show_cycle_reference():
    a, b = OBJ(), OBJ()
    a.attr_b = b
    b.attr_a = a

if __name__ == '__main__':
    # 一定要先禁用gc防止误差
    gc.disable()
    for _ in xrange(50):
        show_cycle_reference()
    # 里面会调用gc.collect()
    # objgraph.show_growth()
    objgraph.show_most_common_types(50)
# 内存中现在有100个OBJ对象
----------------------------------------------------------
# 方式2
import gc, time, objgraph

class OBJ(object):
    pass

def show_cycle_reference():
    a, b = OBJ(), OBJ()
    a.attr_b = b
    b.attr_a = a

if __name__ == '__main__':
    gc.disable()
    gc.set_debug(gc.DEBUG_SAVEALL | gc.DEBUG_OBJECTS)
    for _ in xrange(1):
        show_cycle_reference()
    print gc.garbage  # []
    gc.collect()
    print gc.garbage
    time.sleep(2)

    # 设置了DEBUG_SAVEALL执行collect以后放入了garbage里面
    objgraph.show_backrefs(objgraph.by_type('OBJ')[0], max_depth=20, filename="image4.png")
```

##### 消灭循环引用

```python
# 弱引用
# 创建一个对object的弱引用，返回值为weakref对象，callback: 当object被删除的时候，会调用callback函数
weakref.ref(object, callback = None)

# 弱引用代理
weakref.proxy(object, callback = None)



```

# 新2

# 目标对象

```
只对容器对象有效
```

# 循环引用

##### 概述

```
循环引用导致内存泄漏
只有容器对象之间才会循环引用

del         只使变量所代表的对象的引用计数减1，并在对应空间中删除该变量名
```



##### 循环引用代码

```python
import gc 

class ClassA():
    def __init__(self):
        print("----")

def test():
    while True:
        a1 = ClassA()
        a2 = ClassA()
        a1.b = a2
        a2.b = a1

test()
```

##### 结构体

```c
// 只有容器对象头部有这个结构体, 用于 GC
// 通过 gc_next 和 gc_prev 构成双向循环链表
typedef union _gc_head {
    struct {
        union _gc_head *gc_next; // 指向后一个被跟踪的对象
        union _gc_head *gc_prev; // 指向前一个被跟踪的对象
        Py_ssize_t gc_refs; // 对象引用计数副本 (用于标记清除算法)
    } gc;
    long double dummy; // 用于内存对齐 (8byte 或 16 byte)
} PyGC_Head;
```

##### list 对象

<img src=".\image\gc1.png" alt="gc1" style="zoom:35%;" />

<img src=".\image\gc2.png" alt="gc2" style="zoom:30%;" />

```
这个链表也被称为 可收集 ( collectable )对象链表，Python 将从这个链表中收集并回收垃圾对象
```

# 标记清除

##### gc 模块

```
gc.disable()  					# 暂停自动垃圾回收.
gc.collect()  					# 执行一次完整的垃圾回收, 返回垃圾回收所找到无法到达的对象的数量.
gc.set_threshold(700, 10, 5)  	# 设置Python垃圾回收的阈值.
gc.get_threshold()
gc.set_debug()  				# 设置垃圾回收的调试标记. 调试信息会被写入std.err.
gc.garbage						# 是一个list对象，列表项是垃圾收集器发现的不可达（即垃圾对象）、但又不能释放(不可回收)的对象，通常gc.garbage中的对象是引用对象还中的对象。因Python不知用什么顺序来调用对象的__del__函数，导致对象始终存活在gc.garbage中，造成内存泄露
```

##### 垃圾回收时机

- 自动回收

  ```
  gc.enable()
  gc.disable()
  gc.isenabled()
  gc.get_threshold()
  gc.set_threshold(700, 10, 5)
  ```

- 手动回收

  ```
  执行gc.collect()一次垃圾回收(开关状态无效)
  import objgraph
  import gc
  import sys
  class Person(object):
      pass
  class Dog(object):
      pass
  p = Person()
  d = Dog()
  p.pet = d
  d.master = p
  del p
  del d
  gc.collect()
  print(objgraph.count("Person"))
  print(objgraph.count("Dog"))
  ```

- 程序退出

  ```
  
  ```

  分代回收

##### 作用

```
提升垃圾回收效率, 每次执行标记清除法不用遍历所有对象. 对象存活时间越长, 被释放的概率越低, 降低回收频率
因此根据执行 gc 的频率分为 0, 1, 2 代, 越老执行 gc 频率越低
```

##### 结构体

```c
#define NUM_GENERATIONS 3 // 分为 3 代

// 每一代都是一个 gc_generation 结构体
struct gc_generation {
    PyGC_Head head; // 可收集对象链表头部
    int threshold; // 当 count 超过本阀值时垃圾回收才会扫描本代对象
    int count; // 计数器
};


// 0, 1, 2 代初始化
// 程序初始化时每代 gc_generation 结构体链表是空的, count 为 0, 阀值 threshold 有各自的策略
struct gc_generation generations[NUM_GENERATIONS] = {
    /* PyGC_Head,                                 threshold,      count */
    {{{_GEN_HEAD(0), _GEN_HEAD(0), 0}},           700,            0},
    {{{_GEN_HEAD(1), _GEN_HEAD(1), 0}},           10,             0},
    {{{_GEN_HEAD(2), _GEN_HEAD(2), 0}},           10,             0},
};
```

##### 过程

```
1. 
2. 某代执行 gc 时, 所有比它轻的也执行 gc
3. 执行完 gc 后, 当前代和年轻代 count 清零, 而后代 count +1
4. 执行完 gc 后, 每一代的容器对象都会转移到各自的下一代
4. 多代执行 gc 时 Python 将它们的对象链表拼接在一起, 一次性处理



0 代:
容器对象刚创建时位于 0 代
当创建容器对象时, 将 0 代 count 计数器 +1, 把对象加入 0 代对象链表
当释放容器对象时, 将 0 代 count 计数器 -1, 把对象从 0 代对象链表移除
当 _PyObject_GC_Alloc 的 count 后如果超过 threshold, 将调用 collect_generations 执行一次垃圾回收 (即容器对象创建对象和释放对象差值超过 700 时), 并将 0 代的 count 清零, 1 代的 count + 1


1 代:
每执行 11 次新生代 GC ，触发一次中生代 GC


2 代:
每执行 11 次中生代 GC ，触发一次老生代 GC (老生代 GC 还受其他策略影响，频率更低)
```

##### 例子

<img src=".\image\分代回收1.png" alt="分代回收1" style="zoom:25%;" />

```
1. 0 和 1 代都达到了执行 gc 的条件
2. 先执行 collect_generations 函数遍历每一代, 找出需要执行 gc 中最老的. (假如这里是 1 代)
```

<img src=".\image\分代回收2.png" alt="分代回收2" style="zoom:23%;" />

```
3. 执行 collection_with_callback(1)
4. 执行 collect(1) 将后一个生代 count +1, 再将本代和所有比它年轻生 count 清零
5. 执行 gc_list_merge 将所有要执行 gc 的链表合并到本代中, 一起进行 gc
```



<img src=".\image\分代回收3.png" alt="分代回收3" style="zoom:23%;" />

```
6. 执行 collect 函数的标记清除算法, 对合并后的链表进行垃圾回收, 不可达的对象回收, 可达对象移入下一代
```

# 弱引用

```

```

# 内存溢出

````
当内存溢出时, 不会自动调用gc, 因为gc更看重的是垃圾对象的个数, 而不是大小. 对于长时间运行的程序, 尤其是一些服务器应用, 人为主动的调用gc是非常有必要的
````



# 如何避免

```
尽可能避免循环引用产生, 一方使用弱引用代替
当删除一个引用, 确定以后不再使用时, 手动清空对其他容器对象的引用

测量对象的引用个数
辅助工具  objgraph
			             
```



# 参考

```
多内容
	https://fasionchan.com/python-source/memory/gc/



https://andrewpqc.github.io/2018/10/08/python-memory-management/
https://zhuanlan.zhihu.com/p/83251959


https://www.cnblogs.com/Leon-The-Professional/p/10137405.html

```

