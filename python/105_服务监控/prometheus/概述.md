##### 优点

```
轻量管理：架构简单，不依赖外部存储，单个服务器节点可直接工作，二进制文件启动即可，属于轻量级的 Server，便于迁移和维护。
较强的处理能力：监控数据直接存储在 Prometheus Server 本地的时序数据库中，单个实例可以处理数百万的 Metrics。
灵活的数据模型：多维数据模型，聚合统计更方便。
强大的查询语句：PromQL 允许在同一个查询语句中，对多个 Metrics 进行加法、连接和取分位值等操作。
很好地支持云环境：能自动发现容器，同时 K8s 和 Etcd 等项目都提供了对 Prometheus 的原生支持，是目前容器监控最流行的方案。
下面是 Prometheus 的劣势：
```

##### 缺点

```
功能不够完善：Prometheus 从一开始的架构设计就是要做到简单，不提供集群化方案，长期的持久化存储和用户管理，而这些是企业变大后所必须的特性，目前要做到这些只能在 Prometheus 之上进行扩展。
网络规划变复杂：由于 Prometheus 采用的是 Pull 模型拉取数据，意味着所有被监控的 Endpoint 必须是可达的，需要合理规划网络的安全配置。
```

##### 适用场景

```
更适合云环境下监控，特别是k8s系统下的服务监控
```

##### 架构图

![Prometheus架构](./image/Prometheus架构.png)

## 数据采集

##### 采集数据的格式

- prometheus 存储的是 time series 数据, 以时间维度存储

- time series (时序): 由 Metric 以及一组 key/value 标签定义的，具有相同的名字以及标签属于相同时序

- metric: 就是一个名字, 只能有字母、数字、下划线, 冒号. 起个有意义的名字方便看懂什么意思.

  ```
  # 格式:
  <metric name>{<label name=<label value>, ...}
  
  # 示例:
  http_requests_total{method="POST", status="200“}
  
  # 查询响应为 200 的数据
  http_request_total{status="200"}
  ```

- sample (样本): 按照某个时序以时间维度采集的数据

##### Metric 的4种类型

- Counter: 一种累加的metric，如请求的个数，结束的任务数，出现的错误数等
- Gauge: 常规的metric,如温度，可任意加减。其为瞬时的，与时间没有关系的，可以任意变化的数据。
- Histogram: 柱状图, 根据统计区间计算
  - 假设使用 Hitogram 来分析 API 调用的响应时间，使用数组 [30ms, 100ms, 300ms, 1s, 3s, 5s, 10s] 将响应时间分为 8 个区间。那么每次采集到响应时间，比如 200ms，那么对应的区间 (0, 30ms], (30ms, 100ms], (100ms, 300ms] 的计数都会加 1。最终以响应时间为横坐标，每个区间的计数值为纵坐标，就能得到 API 调用响应时间的累积直方图。
- Summary: 类似Histogram，用于表示一段时间内数据采样结果，其直接存储 quantile (分位数) 结果，而不是根据统计区间计算
  - 分位数: 例如对于一个 http 请求调用了 100 次，得到 100 个响应时间值。将这 100 个时间响应值按照从小到大的顺序排列，那么 0.9 分位数（90% 位置）就代表着第 90 个数
